      MODULE UNIT_TEST_MODULE
C
C     WRITTEN BY: MATTHEW STADELMAN
C     FILE DESCRIPTION: ACTS AS A HELPER MODULE TO HANDLE UNIT TESTING OF CODE.
C
C     LAST MODIFIED: 2016/07/14
C ----------------------------------------------------------------------
C               ---- VARIABLE DESCRIPTIONS ----
C
C  IOUT - UNIT NUMBER TO WRITE STANDARD OUTPUT
C  IERR - UNIT NUMBER TO WRITE STANDARD ERROR
C  MAX_MES_LEN - MAXIMUM NUMBER OF CHARACTERS A LOG MESSAGE CAN BE
C  PASSING - .TRUE. IF ALL TESTS HAVE PASSED
C  PROSECUTOR - THE FILE HOLDING THE TEST SUBROUTINES
C  DEFENDANT - THE FILE BEING TESTED
C
C ----------------------------------------------------------------------
C
      PUBLIC
C
      INTERFACE ASSERT_EQUALS
        MODULE PROCEDURE ASSERT_EQUALS_CHAR, ASSERT_EQUALS_CHAR_ARRAY
        MODULE PROCEDURE ASSERT_EQUALS_INT
      END INTERFACE
C
      INTEGER,SAVE :: IOUT, IERR, MAX_MES_LEN
      LOGICAL,SAVE :: PASSING
      CHARACTER(80), SAVE :: PROSECUTOR, DEFENDANT, PASS_FMT, FAIL_FMT
C
C
      CONTAINS
C
      SUBROUTINE INITIALIZE_TEST_MODULE
        !
        ! WRITTEN BY: MATTHEW STADELMAN
        ! LAST MODIFIED: 2016/07/14
        !
        ! PURPOSE: INITIALIZES TESTING VARIABLES
        !
        IMPLICIT NONE
        !
        IERR = 0
        IOUT = 6
        MAX_MES_LEN = 256
        PASS_FMT = "(2X,A,' - ',A,' : ',A,2X,'PASSED')"
        FAIL_FMT = "(2X,A,' - ',A,' : ',A,2X,'FAILED')"
        PASSING = .TRUE.
        CALL STO_MESSAGE(' SUCESSFULLY INITIALIZED TESTING MODULE')
        CALL STO_MESSAGE(' ')
        !
        RETURN
      END SUBROUTINE
C
      SUBROUTINE STO_MESSAGE(COUT)
        !
        ! WRITTEN BY: MATTHEW STADELMAN
        ! LAST MODIFIED: 2016/07/14
        !
        ! PURPOSE: WRITES A MESSAGE TO STDOUT OR EQUIVALENT LOG FILE
        !
        IMPLICIT NONE
        CHARACTER(*) :: COUT
        !
        WRITE(IOUT,"(A)") TRIM(COUT)
        !
        RETURN
      END SUBROUTINE
C
      SUBROUTINE STE_MESSAGE(COUT)
        !
        ! WRITTEN BY: MATTHEW STADELMAN
        ! LAST MODIFIED: 2016/07/14
        !
        ! PURPOSE: WRITES A MESSAGE TO STDERR OR EQUIVALENT LOG FILE
        !
        IMPLICIT NONE
        CHARACTER(*) :: COUT
        !
        WRITE(IERR,"(A)") TRIM(COUT)
        !
        RETURN
      END SUBROUTINE
C
      SUBROUTINE ASSERT_EQUALS_CHAR(VAL1, VAL2, TESTEE)
        !
        ! WRITTEN BY: MATTHEW STADELMAN
        ! LAST MODIFIED: 2016/07/14
        !
        ! PURPOSE: TESTS IF TWO STRINGS ARE EQUAL
        !
        IMPLICIT NONE
        CHARACTER(*) :: VAL1, VAL2, TESTEE
        CHARACTER(MAX_MES_LEN) :: CVAR, PRO
        !
        PRO = PROSECUTOR
        IF (TRIM(VAL1) == TRIM(VAL2)) THEN
          WRITE(CVAR,PASS_FMT)TRIM(PRO),TRIM(DEFENDANT),TRIM(TESTEE)
          CALL STO_MESSAGE(CVAR)
        ELSE
          PASSING = .FALSE.
          WRITE(CVAR,FAIL_FMT)TRIM(PRO),TRIM(DEFENDANT),TRIM(TESTEE)
          CALL STE_MESSAGE(CVAR)
          PRINT *, VAL1, '-' ,VAL2
          WRITE(CVAR,"(8X,A,' != ',A)")TRIM(VAL1), TRIM(VAL2)
          CALL STE_MESSAGE(CVAR)
        END IF
        !
        RETURN
      END SUBROUTINE
C
      SUBROUTINE ASSERT_EQUALS_CHAR_ARRAY(ARR1, ARR2, TESTEE)
        !
        ! WRITTEN BY: MATTHEW STADELMAN
        ! LAST MODIFIED: 2016/07/14
        !
        ! PURPOSE: TESTS IF TWO CHARACTER ARRAYS ARE EQUAL
        !
        IMPLICIT NONE
        INTEGER :: I
        LOGICAL :: LEN_FAIL, VAL_FAIL
        CHARACTER(*) :: ARR1(:), ARR2(:), TESTEE
        CHARACTER(80) :: LEN_FMT, VAL_FMT
        CHARACTER(MAX_MES_LEN) :: CVAR, LENM, VALM, PRO
        !
        LEN_FMT = "(8X,'ARRAY LENGTH DIFFERS: ',I0,' != ',I0)"
        VAL_FMT = "(8X,'ARRAY VALUES DIFFER:')"
        PRO = PROSECUTOR
        WRITE(CVAR,PASS_FMT)TRIM(PRO),TRIM(DEFENDANT),TRIM(TESTEE)
        !
        ! TESTING ARRAY LENGTH
        IF (SIZE(ARR1) /= SIZE(ARR2)) THEN
          PASSING = .FALSE.
          LEN_FAIL = .TRUE.
          WRITE(LENM,LEN_FMT)SIZE(ARR1),SIZE(ARR2)
        END IF
        !
        ! TESTING ARRAY VALUES
        DO I = 1, MIN(SIZE(ARR1),SIZE(ARR2))
          IF (TRIM(ARR1(I)) /= TRIM(ARR2(I))) THEN
            PASSING = .FALSE.
            VAL_FAIL = .TRUE.
            WRITE(VALM,VAL_FMT)
          END IF
        END DO
        !
        ! ERROR MESSAGES
        IF (LEN_FAIL .OR. VAL_FAIL) THEN
          WRITE(CVAR,FAIL_FMT)TRIM(PRO),TRIM(DEFENDANT),TRIM(TESTEE)
          CALL STE_MESSAGE(CVAR)
        ELSE
          WRITE(CVAR,PASS_FMT)TRIM(PRO),TRIM(DEFENDANT),TRIM(TESTEE)
          CALL STO_MESSAGE(CVAR)
        END IF
        !
        IF (LEN_FAIL) THEN
          CALL STE_MESSAGE(LENM)
        END IF
        !
        IF (VAL_FAIL) THEN
          CALL STE_MESSAGE(VALM)
          WRITE(IERR,*)'ARR1',' ARR2'
          DO I = 1, MAX(SIZE(ARR1),SIZE(ARR2))
            IF (I <= SIZE(ARR1) .AND. I <= SIZE(ARR2)) THEN
              WRITE(IERR,*)TRIM(ARR1(I)),', ',TRIM(ARR2(I))
            END IF
            IF (I < SIZE(ARR1) .AND. I >= SIZE(ARR2)) THEN
              WRITE(IERR,*) TRIM(ARR1(I)), ',  ? '
            END IF
            IF (I >= SIZE(ARR1) .AND. I < SIZE(ARR2)) THEN
              WRITE(IERR,*) ' ?  , ',TRIM(ARR2(I))
            END IF
          END DO
        END IF
        !
        RETURN
      END SUBROUTINE
C
      SUBROUTINE ASSERT_EQUALS_INT(VAL1, VAL2, TESTEE)
        !
        ! WRITTEN BY: MATTHEW STADELMAN
        ! LAST MODIFIED: 2016/07/14
        !
        ! PURPOSE: TESTS IF TWO INTEGERS ARE EQUAL
        !
        IMPLICIT NONE
        INTEGER :: VAL1, VAL2
        CHARACTER(*) :: TESTEE
        CHARACTER(MAX_MES_LEN) :: CVAR, PRO
        !
        PRO = PROSECUTOR
        IF (VAL1 == VAL2) THEN
          WRITE(CVAR,PASS_FMT)TRIM(PRO),TRIM(DEFENDANT),TRIM(TESTEE)
          CALL STO_MESSAGE(CVAR)
        ELSE
          PASSING = .FALSE.
          WRITE(CVAR,FAIL_FMT)TRIM(PRO),TRIM(DEFENDANT),TRIM(TESTEE)
          CALL STE_MESSAGE(CVAR)
          WRITE(CVAR,"(8X,I0,' != ',I0)")VAL1, VAL2
          CALL STE_MESSAGE(CVAR)
        END IF
        !
        RETURN
      END SUBROUTINE
C
      END MODULE