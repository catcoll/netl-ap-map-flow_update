      SUBROUTINE OUTPUT_DATA(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTON: OUTPUTS THE DATA FROM THE LCL MODEL INTO
C         INTO SEVERAL FILES FOR POST-PROCESSING AND VIEWING.
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/07/13
C
C     SUBROUTINE CALLS: INIT_OUTPUT, CALC_PERCENTILE, WRITE_PERCENTILE
C         WRITE_STATS_FILE, WRITE_DATA_MAP
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       PQX_OUT - X FLOW DATA USED FOR VECTOR PLOTTING
C       PQZ_OUT - Z FLOW DATA USED FOR VECTOR PLOTTING
C       PQZ_OUT - FLOW MAGNITUDE DATA USED FOR FLOW MAP AND REYNOLDS CALCULATION
C       PRES - FLATTENED VERSION OF FRAC_PR, WITHOUT BOUNDARY CELLS
C       REN - ARRAY THAT STORES THE ESTIMATED REYNOLDS NUMBER FOR A CELL
C       RES - ARRAY THAT STORES NORMALIZED MASS/GAIN LOSSES FOR A CELL
C       X,Y,Z - POINT COORDINATES USED TO CREATE VTK MESH
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
C
      IMPLICIT NONE
      REAL(8), ALLOCATABLE :: PQX_OUT(:),PQZ_OUT(:),PQM_OUT(:),PRES(:)
      REAL(8), ALLOCATABLE :: REN(:),RES(:)
      REAL(8) :: FLOW,X,Y,Z
      INTEGER :: I,N,IX,IZ,IC,LB
      LOGICAL :: BOK
C
C     INITIALIZING VARIABLES
      LB = NX*NZ
      ALLOCATE(PQX_OUT(LB),PQZ_OUT(LB),PQM_OUT(LB),PRES(LB))
      ALLOCATE(RES(LB),REN(LB))
C
C     INITIALIZING OUTPUT FILES
      CALL INIT_OUTPUT(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     CALCULATING FLOW RATE FROM FRACTURE
      FLOW = 0.0
      DO IC = 1,NC
        I = OUTLET(IC)
        IF (INDEX(OUTLET_SIDE,'LEFT') > 0)   FLOW = FLOW + Q(1,I)
        IF (INDEX(OUTLET_SIDE,'RIGHT') > 0)  FLOW = FLOW + Q(2,I)
        IF (INDEX(OUTLET_SIDE,'TOP') > 0)    FLOW = FLOW + Q(3,I)
        IF (INDEX(OUTLET_SIDE,'BOTTOM') > 0) FLOW = FLOW + Q(4,I)
      END DO
      OUTRATE = ABS(FLOW)
C
C     NORMALIZING RESIDUAL ARRAY BY THE LARGEST RESIDUAL VALUE
      RES = ABS(Q(5,1:LB))
      RES = RES/MAXVAL(RES)
C
C     DEFAULT DIRECTIONS ARE RIGHT AND TOP
      PQX_OUT = Q(2,1:LB)
      PQZ_OUT = Q(4,1:LB)
C
C     CHECKING IF OUTLET IS ON A DIFFERENT SIDE
      IF (INDEX(OUTLET_SIDE,'LEFT') > 0) THEN
        PQX_OUT = Q(1,1:LB)
      ELSEIF (INDEX(OUTLET_SIDE,'BOTTOM') > 0) THEN
        PQZ_OUT = Q(3,1:LB)
      END IF
C
C     CALCULATING FLOW MAGNITUDE AND APPROXIMATE REYNOLDS NUMBER
      DO I = 1,LB
        PQM_OUT(I) = SQRT(PQX_OUT(I)**2+PQZ_OUT(I)**2)
        REN(I) = (RHO*PQM_OUT(I))/(AVG_VISC*WIDTH(I))
      END DO
C
C     CREATING FLATTENED PRESSURE ARRAY
      DO IZ =1,NZ
        DO IX = 1,NX
          I = (IZ - 1)*NX + IX
          PRES(I) = FRAC_PR(IZ,IX)
        END DO
      END DO
C
C     CONVERTING VALUES IN INTERNAL UNITS TO OUTPUT UNITS
      AP_MAP = AP_MAP*DIM_CONV
      PRES = PRES*PRES_CONV
      INLPB = INLPB*PRES_CONV
      OUTPB = OUTPB*PRES_CONV
      DX = DX*DIM_CONV
      DZ = DZ*DIM_CONV
      WIDTH = WIDTH*DIM_CONV
      OUTRATE = OUTRATE*RATE_CONV
      PQX_OUT = PQX_OUT*RATE_CONV
      PQZ_OUT = PQZ_OUT*RATE_CONV
      PQM_OUT = PQM_OUT*RATE_CONV
C
C     LOGGING FINAL PRESSURES, FLOW RATES AND RESIDUAL TO SCREEN
      CALL BLANK
      WRITE(CVAR,2000) 'INLET',INLPB,TRIM(UNIT_OUT(1))
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2000) 'OUTLET',OUTPB,TRIM(UNIT_OUT(1))
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2100) 'NET',OUTRATE,TRIM(UNIT_OUT(5))
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2200) Q(5,MAXLOC(ABS(Q(5,1:LB))))
      CALL MESSAGE(CVAR)
C
C     CALCULATING FLOW RATE PERCENTILES FOR X, Z COMPONENTS AND MAGNITUDE
      IF (PERCENTILE) THEN
        CALL CALC_PERCENTILE(PQX_OUT,PERC_ARR,NX*NZ,NPCT)
        CALL WRITE_PERCENTILE('X-FLOW',UNIT_OUT(5))
        !
        CALL CALC_PERCENTILE(PQZ_OUT,PERC_ARR,NX*NZ,NPCT)
        CALL WRITE_PERCENTILE('Z-FLOW',UNIT_OUT(5))
        !
        CALL CALC_PERCENTILE(PQM_OUT,PERC_ARR,NX*NZ,NPCT)
        CALL WRITE_PERCENTILE('FLOW MAGNITUDE',UNIT_OUT(5))
C
C       CALCULATING PERCENTILES FOR THE NORMALIZED RESIDUAL
        CALL CALC_PERCENTILE(RES,PERC_ARR,NX*NZ,NPCT)
        CALL WRITE_PERCENTILE('NORMALIZED RESIDUAL','-')
      END IF
C
      CALL BLANK
      CALL MESSAGE(" WRITING DATA TO OUTPUT FILES...")
C
C     OUTPUTTING DATA TO STATS FILE
      CALL WRITE_STATS_FILE(FLOW)
C
C     OUTPUTTING THE WIDTH VECTOR USED IN THE SIMULATION
      CALL WRITE_ONED_ARRAY(IMAP, WIDTH, NX, NZ, "(*(G15.8,:,','))")
      CALL MESSAGE("     ADJUSTED APERTURE FILE COMPLETED")
C
C     OUTPUTTING QX, QZ AND FLOW MAGNITUDE VALUES
      CALL WRITE_ONED_ARRAY(IFLOX, PQX_OUT, NX, NZ, "(*(G15.8,:,','))")
      CALL WRITE_ONED_ARRAY(IFLOZ, PQZ_OUT, NX, NZ, "(*(G15.8,:,','))")
      CALL WRITE_ONED_ARRAY(IFLOM, PQM_OUT, NX, NZ, "(*(G15.8,:,','))")
      CALL MESSAGE("     FLOW FILE COMPLETED")
C
C     OUTPUTTING THE FRACTURE PRESSURE DISTRIBUTION
      CALL WRITE_ONED_ARRAY(IPRES, PRES, NX, NZ, "(*(G15.8,:,','))")
      CALL MESSAGE("     PRESSURE FILE COMPLETED")
C
C     CREATING THE VTK FILE'S HEADERS FOR PARAVIEW EXPORT
      CALL BLANK
      CALL MESSAGE("     CREATING THE VTK FILE...")
      WRITE(IVTK,"('# vtk DataFile Version 3.0')")
      WRITE(IVTK,"('vtk output')")
      WRITE(IVTK,"('ASCII')")
      WRITE(IVTK,"('DATASET STRUCTURED_GRID')")
      WRITE(IVTK,"('DIMENSIONS ',I0,1X,I0,1X,I0)")NX+1,NZ+1,2
      WRITE(IVTK,"('POINTS ',I0,' float')")(NX+1)*(NZ+1)*2
C
C     OUTPUTTING BOTTOM AND TOP SURFACE POINTS FOR THE GRID
      DO N = -1,1,2
        Z = 0.0
        DO IZ = 1,NZ
          X = 0.0
          Y = N*AP_MAP(IZ,1,1)/2.0
          WRITE(IVTK,"(3(E14.6,:,' '))")X,Y,Z
          DO IX = 1,NX
            I = (IZ - 1)*NX + IX
            X = X + DX(I)
            Y = N*AP_MAP(IZ,IX,2)/2.0
            WRITE(IVTK,"(3(E14.6,:,' '))")X,Y,Z
          END DO
          Z = Z + DZ(I)
        END DO
        !
        X = 0.0
        Y = N*AP_MAP(NZ,1,4)/2.0
        WRITE(IVTK,"(3(E14.6,:,' '))")X,Y,Z
        DO IX = 1,NX
          I = (NZ - 1)*NX + IX
          X = X + DX(I)
          Y = N*AP_MAP(NZ,IX,3)/2.0
          WRITE(IVTK,"(3(E14.6,:,' '))")X,Y,Z
        END DO
      END DO
      CALL MESSAGE("         VTK POINTS OUTPUT TO FILE")
C
C     OUTPUTTING SIMULATION DATA INTO THE VTK FILE
      CALL BLANK
      CALL MESSAGE("     OUTPUTTING DATA TO THE VTK FILE...")
C
C     CREATING THE CELL DATA TABLES
      WRITE(IVTK,"(' ')")
      WRITE(IVTK,"('CELL_DATA ',I0)") NX*NZ*1
      CALL WRITE_VTK_DATA('APERTURE',UNIT_OUT(2),'float',WIDTH)
      CALL WRITE_VTK_DATA('PRESSURE',UNIT_OUT(1),'float',PRES)
      CALL WRITE_VTK_DATA('REYNOLDS_NUMBER','-','float',REN)
      CALL WRITE_VTK_DATA('NORMALIZED_RESIDUALS','-','float',RES)
C
      WRITE(IVTK,"(' ')")
      WRITE(IVTK,"('VECTORS FLOW[',A,'] float')")TRIM(UNIT_OUT(5))
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ - 1)*NX + IX
          WRITE(IVTK,"(3(E14.6,:,' '))")PQX_OUT(I),0.0,PQZ_OUT(I)
        END DO
      END DO
      CALL MESSAGE("         VECTOR FLOW DATA OUTPUT TO VTK FILE")
C
C     DEALLOCATING ARRAYS
      DEALLOCATE(PQX_OUT,PQZ_OUT,PQM_OUT,PRES,REN,RES)
      CALL DEALLOCATE_FRAC
C
      CALL BLANK
      CALL MESSAGE(" DEALLOCATED ALL ARRAYS")
C
      RETURN
C
 1000 BOK = .FALSE.
      RETURN
C
 2000 FORMAT(5X,A,' BOUNDARY PRESSURE: ',G20.9,1X,A)
C
 2100 FORMAT(5X,A,' FLOW RATE CALCULATED: ',G20.9,1X,A)
C
 2200 FORMAT(5X,'MAXIMUM NET FLOW RESIDUAL: ',G20.9,1X,A)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE INIT_OUTPUT(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     LAST MODIFIED: 2016/07/12
C
C     PROGRAM DESCRIPTION: PREPARES OUTPUT FILES
C
C     SUBROUTINE CALLS: CALC_CONV_FACT, SET_HEADER
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       CONV - STORES THE VALUE OF EACH UNIT CONVERSION TO PRINT TO SCREEN
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE UNIT_CONVERSION_MODULE
C
      IMPLICIT NONE
      REAL(8) :: CONV(7)
      INTEGER :: I
      LOGICAL :: BOK
C
      CONV(1) = PRES_CONV
      CONV(2) = DIM_CONV
      CONV(4) = TIME_CONV
      CONV(5) = RATE_CONV
      CONV(6) = VISC_CONV
      CONV(7) = RHO_CONV
      UNIT_OUT(6) = UNIT_IN(6)
      UNIT_OUT(7) = UNIT_IN(7)
C
      CALL BLANK
      CALL MESSAGE(" INITIALIZING OUTPUT FILES")
      CALL MESSAGE("     INPUT CONVERSIONS APPLIED")
      CALL CALC_CONV_FACT('PRES',UNIT(1),UNIT_OUT(1),PRES_CONV,BOK)
      CALL CALC_CONV_FACT('DIST',UNIT(2),UNIT_OUT(2),DIM_CONV,BOK)
      CALL CALC_CONV_FACT('TIME',UNIT(4),UNIT_OUT(4),TIME_CONV,BOK)
      CALL CALC_CONV_FACT('RATE',UNIT(5),UNIT_OUT(5),RATE_CONV,BOK)
      CALL CALC_CONV_FACT('VISC',UNIT(6),UNIT_OUT(6),VISC_CONV,BOK)
      CALL CALC_CONV_FACT('DENS',UNIT(7),UNIT_OUT(7),RHO_CONV,BOK)
      IF (.NOT. BOK) GOTO 1000
C
      WRITE(CVAR,1990)
      CALL MESSAGE(CVAR)
      WRITE(CVAR,1980)'UNIT IN','UNIT OUT','CONVERSION'
      CALL MESSAGE(CVAR)
      WRITE(CVAR,1990)
      CALL MESSAGE(CVAR)
      DO I = 1,7
        IF (I == 3) CYCLE
        WRITE(CVAR,2000)UNIT_IN(I),UNIT(I),CONV(I)
      CALL MESSAGE(CVAR)
      END DO
      WRITE(CVAR,1990)
      CALL MESSAGE(CVAR)
C
      CONV(1) = PRES_CONV
      CONV(2) = DIM_CONV
      CONV(4) = TIME_CONV
      CONV(5) = RATE_CONV
      CONV(6) = VISC_CONV
      CONV(7) = RHO_CONV
C
      CALL BLANK
      CALL MESSAGE("     OUTPUT CONVERSIONS APPLIED")
      WRITE(CVAR,1990)
      CALL MESSAGE(CVAR)
      WRITE(CVAR,1980)'UNIT IN','UNIT OUT','CONVERSION'
      CALL MESSAGE(CVAR)
      WRITE(CVAR,1990)
      CALL MESSAGE(CVAR)
      DO I = 1,7
        IF (I == 3) CYCLE
        WRITE(CVAR,2000)UNIT(I),UNIT_OUT(I),CONV(I)
      CALL MESSAGE(CVAR)
      END DO
      WRITE(CVAR,1990)
      CALL MESSAGE(CVAR)
C
      RETURN
C
 1000 BOK = .FALSE.
      RETURN
C
 1980 FORMAT(5X,A10,4X,A10,2X,A15)
 1990 FORMAT(5X,41('-'))
 2000 FORMAT(5X,A10,' -> ',A10,': ',G15.6)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE WRITE_STATS_FILE(FLOW)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     LAST MODIFIED: 2016/10/27
C
C     PROGRAM DESCRIPTION: SETS THE HEADER USED IN CERTAIN OUTPUT FILES
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       FLOW - TOTAL FLOW OUT OF THE FRACTURE
C       NFQ - 1-D EQUIVALENT FLOW
C       AVG_CORR - AVERAGE OF X AND Z CORRELTION LENGTHS, USED IN CALCULATIONS
C       BULK_REN - OVERALL REYNOLDS NUMBER FOR THE FRACTURE
C       HOM_TRANS - AVERAGE FRACTURE TRANSMISSIBILITY
C ----------------------------------------------------------------------
C
      USE APM_MODULE
C
      IMPLICIT NONE
      REAL(8) :: FLOW,NFQ,HOM_TRANS,BULK_REN,AVG_CORR, DP
      INTEGER :: VERT, HORIZ
C
C     CALCULATING FLOW CORRECTION FACTOR AND THE 1-D EQUIVALENT FLOW RATE
      VERT = INDEX(OUTLET_SIDE,'TOP')+INDEX(OUTLET_SIDE,'BOTTOM')
      HORIZ = INDEX(OUTLET_SIDE,'RIGHT')+INDEX(OUTLET_SIDE,'LEFT')
      IF (HORIZ > 0) THEN
        FLOW_CF =   ABS(FLOW/(INLPB-OUTPB)/AVG_TRX)
        NFQ =       ABS(AVG_TRX*(INLPB-OUTPB))
        HOM_TRANS = ABS(FLOW/(INLPB-OUTPB))*AVG_VISC*DIAM
        BULK_REN = (2.0*RHO*FLOW)/(AVG_VISC*LENG)
      ELSEIF (VERT > 0) THEN
        FLOW_CF =   ABS(FLOW/(INLPB-OUTPB)/AVG_TRZ)
        NFQ =       ABS(AVG_TRZ*(INLPB-OUTPB))
        HOM_TRANS = ABS(FLOW/(INLPB-OUTPB))*AVG_VISC*LENG
        BULK_REN = (2.0*RHO*FLOW)/(AVG_VISC*DIAM)
      END IF
C
C     HANDLING UNIT CONVERSIONS
      DIAM = DIAM*DIM_CONV
      LENG = LENG*DIM_CONV
      AVG_APER = AVG_APER*DIM_CONV
      AVG_VISC = AVG_VISC*VISC_CONV
      RHO = RHO*RHO_CONV
      APER_RMS = APER_RMS*DIM_CONV
      APER_DEV = APER_DEV*DIM_CONV
      Z_CORR = Z_CORR*DIM_CONV
      X_CORR = X_CORR*DIM_CONV
      NFQ = NFQ*RATE_CONV
      AVG_CORR = (2.0*X_CORR*Z_CORR)/(X_CORR+Z_CORR)
      DP = (INLPB-OUTPB)/PRES_CONV
C
C    WRITING HEADER INFORMATION FOR CSV FILE
      WRITE(ISTATC,"(A)")'APER-MAP:, ' // TRIM(APM_FILE)
      WRITE(ISTATC,"('NX,NZ',/,I0,',',I0)") NX, NZ
      !
      WRITE(ISTATC,2050) TRIM(UNIT_OUT(2)), TRIM(UNIT_OUT(2)),
     &                   TRIM(UNIT_OUT(2))
      WRITE(ISTATC,2000) LENG, DIAM, AVG_APER
      !
      WRITE(ISTATC,2075) TRIM(UNIT_OUT(6)), TRIM(UNIT_OUT(7))
      WRITE(ISTATC,2000) AVG_VISC, RHO
C
C     OUTPUTTING DATA TO CSV STATISTICS FILE
      WRITE(ISTATC,2100) TRIM(UNIT_OUT(1)), TRIM(UNIT_OUT(1)),
     &                   TRIM(UNIT_OUT(5))
      WRITE(ISTATC,2000) INLPB, OUTPB, OUTRATE
      !
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2125) TRIM(UNIT_OUT(2)), TRIM(UNIT_OUT(2))
      WRITE(ISTATC,2000) APER_RMS, APER_DEV
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2140) TRIM(UNIT_OUT(2)), TRIM(UNIT_OUT(2)),
     &                   TRIM(UNIT_OUT(2))
      WRITE(ISTATC,2000) X_CORR, Z_CORR, AVG_CORR
      !
      WRITE(ISTATC,"(A)")'#'
      WRITE(ISTATC,2150)
      WRITE(ISTATC,2000) APER_DEV/AVG_APER, APER_DEV/AVG_CORR,
     &                   AVG_APER/AVG_CORR
      !
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2175)
      WRITE(ISTATC,2000) BULK_REN, HOM_TRANS, DP
      !
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2200) TRIM(UNIT_OUT(5))
      WRITE(ISTATC,2000) NFQ, FLOW_CF*100
C
C     WRITING DATA TO YAML FILE
      WRITE(ISTATY,"(A)") 'APER-MAP: "' // TRIM(APM_FILE) // '"'
      WRITE(ISTATY,"(A)") 'PVT-FILE: "' // TRIM(PVT_FILE) // '"'
      WRITE(ISTATY, "('NX: ',I0,/,'NZ: ',I0)") NX, NZ
      WRITE(ISTATY, 2500) 'LENGTH', LENG, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'DIAMETER', DIAM, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'MEAN APER', AVG_APER, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'AVG VISC', AVG_VISC, TRIM(UNIT_OUT(6))
      WRITE(ISTATY, 2500) 'DENSITY', RHO, TRIM(UNIT_OUT(7))
      WRITE(ISTATY, 2500) 'INLET PRESS', INLPB, TRIM(UNIT_OUT(1))
      WRITE(ISTATY, 2500) 'OUTLET PRESS', OUTPB, TRIM(UNIT_OUT(1))
      WRITE(ISTATY, 2500) 'OUTLET RATE', OUTRATE, TRIM(UNIT_OUT(5))
      WRITE(ISTATY, 2500) 'APERTURE RMS', APER_RMS, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'APERTURE STDDEV', APER_DEV, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'X-CORR LENGTH', X_CORR, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'Z-CORR LENGTH', Z_CORR, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'AVG-CORR LENGTH', AVG_CORR, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'STDDEV/MEAN APER', APER_DEV/AVG_APER, '-'
      WRITE(ISTATY, 2500) 'STDDEV/AVG CORR LEN', APER_DEV/AVG_CORR, '-'
      WRITE(ISTATY, 2500) 'MEAN APER/AVG CORR LEN',AVG_APER/AVG_CORR,'-'
      WRITE(ISTATY, 2500) 'BULK REYNOLDS NUM', BULK_REN, '-'
      WRITE(ISTATY, 2500) 'AVERAGE TRANSMISSIBILTY', HOM_TRANS, 'M^4'
      WRITE(ISTATY, 2500) 'PRESSURE DIFFERENTIAL', DP, 'PA'
      WRITE(ISTATY, 2500) '1-D EQUIV', NFQ, TRIM(UNIT_OUT(5))
      WRITE(ISTATY, 2500) 'PERC OF 1-D', FLOW_CF*100, '-'
C
      RETURN
C
C     CSV FILE FORMATS
 2000 FORMAT(*(G20.12,:,','))
C
 2050 FORMAT('LENGTH [',A,'],DIAMETER [',A,'],MEAN APER [',A,'],')
C
 2075 FORMAT('AVG VISC [',A,'],DENSITY [',A,']')
C
 2100 FORMAT('INLET PRESS [',A,'],OUTLET PRESS [',A,'],',
     &       'OUTLET RATE [',A,']')
C
 2125 FORMAT('APERTURE RMS [',A,'],APERTURE STDDEV [',A,']')
C
 2140 FORMAT('X-CORR LENGTH [',A,'],Z-CORR LENGTH [',A,'],',
     &       'AVG-CORR LENGTH [',A,']')
C
 2150 FORMAT('STDDEV/MEAN APER [-],STDDEV/AVG CORR LEN [-],',
     &       ' MEAN APER/AVG CORR LEN [-]')
C
 2175 FORMAT('BULK REYNOLDS # [-],AVERAGE TRANSMISSIBILTY [M^4],',
     &       'PRESSURE DIFFERENTIAL [PA]')
C
 2200 FORMAT('1-D EQUIV [',A,'],PERC OF 1-D [-]')
C
C     YAML FILE FORMATS
 2500 FORMAT(A,': ','[',G20.12,',"',A,'"]')
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE WRITE_PERCENTILE(TITLE, UNIT)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     LAST MODIFIED: 2016/07/12
C
C     PROGRAM DESCRIPTION: OUTPUTS A PERCENTILE IN STANDARD FORMAT
C
C     SUBROUTINE CALLS: MESSAGE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       UNIT - UNITS ON THE PERCENTILE VALUES
C       TITLE - HEADER OF THE PERCENTILE TABLE
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE, ONLY : PERC_ARR, NPCT, CVAR
C
      IMPLICIT NONE
      INTEGER :: I
      CHARACTER(*) :: TITLE, UNIT
      CHARACTER(80) :: UNIT_STR
C
      WRITE(UNIT_STR,"('[',A,']')") TRIM(UNIT)
C
      CALL BLANK
      WRITE(CVAR,2100)
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2000) TRIM(TITLE)
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2100)
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2200)'PERCENTILE', TRIM(UNIT_STR)
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2100)
      CALL MESSAGE(CVAR)
      DO I = 1,NPCT
        WRITE(CVAR,2300)PERC_ARR(1,I),PERC_ARR(2,I)
        CALL MESSAGE(CVAR)
      END DO
      WRITE(CVAR,2100)
      CALL MESSAGE(CVAR)
C
      RETURN
C
C     FORMATS
C
 2000 FORMAT(9X,A,1X,'RANGES')
C
 2100 FORMAT(9X,32('-'))
C
 2200 FORMAT(1X,A18,3X,'|',A17)
C
 2300 FORMAT(9X,'|',2X,F7.3,3X,'|',1X,F15.6,1X,'|')
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE WRITE_ONED_ARRAY(IUNIT, DATA_ARRAY, NX, NZ, FMT_STR)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     LAST MODIFIED: 2016/07/13
C
C     SUBROUTINE DESCRIPTION: OUTPUTS A VECTOR INTO A 2-D DATA MAP
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       IUNIT - FILE UNIT NUMBER
C       NX,NZ - DATA EXTENTS ALONG EACH AXIS
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8) :: DATA_ARRAY(*)
      INTEGER :: IUNIT, NX, NZ
      INTEGER :: IZ, I, J
      CHARACTER(*) :: FMT_STR
      !
      DO IZ = 0,NZ-1
        I = IZ*NX+1
        J = IZ*NX+NX
        WRITE(IUNIT,FMT_STR) DATA_ARRAY(I:J)
      END DO
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE WRITE_VTK_DATA(FNAME,UNIT,DTYPE,DATA_ARRAY)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     LAST MODIFIED: 2016/07/13
C
C     SUBROUTINE DESCRIPTION: OUTPUTS A DATA VECTOR INTO THE VTK FILE
C
C     SUBROUTINE CALLS: WRITE_ONED_ARRAY
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       FNAME - FIELD NAME
C       UNIT - PHYSICAL UNITS OF DATA
C       DTYPE - PARAVEW DATA TYPE
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE, ONLY : IVTK, NX, NZ
C
      IMPLICIT NONE
      REAL(8) :: DATA_ARRAY(*)
      CHARACTER(*) :: FNAME, UNIT, DTYPE
      CHARACTER(80) :: FMT_STR = "(*(1(E14.6,:,' '), /, :))"
C
C     CREATING THE DATA TABLE
      WRITE(IVTK,"(' ')")
      WRITE(IVTK,2000) TRIM(FNAME),TRIM(UNIT),TRIM(DTYPE)
      WRITE(IVTK,"('LOOKUP_TABLE default')")
C
      CALL WRITE_ONED_ARRAY(IVTK,DATA_ARRAY,NX,NZ,FMT_STR)
      CALL MESSAGE("         "//TRIM(FNAME)//" DATA OUTPUT TO VTK FILE")
C
      RETURN
C
 2000 FORMAT('SCALARS ',A,'[',A,'] ',A)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C