C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE INITIALIZE_RUN(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: CONTROLS CALLING OF THE MODEL INITALIZATION
C     ROUTINES AND SETS DEFAULT MODEL PARAMETERS.
C
C     SUBROUTINE CALLS: ASSIGN_IO, READ_MASTER, READ_AP_MAP, INIT_PVT,
C                       COEF, FLOW_BOUNDARY, INIT_OUTPUT
C
C     LAST MODIFIED: 2016/10/27
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE UNIT_CONVERSION_MODULE
C
      IMPLICIT NONE
      LOGICAL :: BOK
C
C     DEFAULT VALUES
      IOUT = 6 !SETTING TO STDOUT INITIALLY
      ! DEFAULT PERCENTILE SETTINGS
      PERCENTILE = .FALSE.
      ALLOCATE(PERC_ARR(2,9))
      NPCT = 9
      PERC_ARR(1,1:9) = [1,5,10,25,50,75,90,95,99]
      ! NOT USING AN OUTLFOW MANIFOLD
      MANIFOLD   = .FALSE.
      ! DEFAULT TO PRESSURE BOUNDARY CONDITION
      RATEC  = .FALSE.
      PRESC  = .FALSE.
      INLPB    = -1.0
      OUTPB  = -1.0
      OUTRATE = -1.0
      INJRATE = -1.0
      ! DEFAULT LIQUID PROPERIES
      RHO    = 1.0
      AVG_VISC = -1.0
      ! DEFAULT APERTURE MAP PROPERTIES
      MAXDIM    = 500
      AVG_FACT  = 1.0
      R_FACT    = 0.0
      VOX_MET   = 1.0
      HIGH_MASK = 10000.0
      LOW_MASK  = 1E-6
      OUTLET_SIDE   = 'TOP'
      UNIT(:)     = 'SI'
      UNIT_IN(1)  = 'PA'
      UNIT_IN(2)  = 'M'
      UNIT_IN(3)  = 'K'
      UNIT_IN(4)  = 'SEC'
      UNIT_IN(5)  = 'M^3/SEC'
      UNIT_IN(6)  = 'PA*SEC'
      UNIT_IN(7)  = 'KG/M^3'
      UNIT_OUT(1) = 'PA'
      UNIT_OUT(2) = 'M'
      UNIT_OUT(3) = 'K'
      UNIT_OUT(4) = 'SEC'
      UNIT_OUT(5) = 'M^3/SEC'
      UNIT_OUT(6) = 'PA*SEC'
      UNIT_OUT(7) = 'KG/M^3'
C
C     INITIALIZING IO
      CALL OPEN_IO(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     READING INPUT FILE
      CALL READ_MASTER(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     CHECKING IF BOTH INLET AND OUTLET PRESSURE CONDITION WERE SUPPLIED
      IF ((INLPB .GE. 0) .AND. (OUTPB .GE. 0)) THEN
        PRESC = .TRUE.
        CALL MESSAGE("     FRACTURE FLOW IS PRESSURE CONTROLLED")
      ELSE
        PRESC = .FALSE.
        CALL MESSAGE("     FRACTURE FLOW IS RATE CONTROLLED")
      END IF
C
C     CHECKING VISCOSITY VALUE PROVIDED
      IF (AVG_VISC > 0) THEN
        WRITE(CVAR,2000) AVG_VISC/VISC_CONV,TRIM(UNIT_IN(6))
        CALL MESSAGE(CVAR)
      ELSE
        WRITE(CVAR,2010) AVG_VISC/VISC_CONV
        CALL MESSAGE(CVAR)
        GOTO 1000
      END IF
C
C     SETTING CONVERSION VALUES
      CALL CALC_CONV_FACT('PRES',UNIT_IN(1),UNIT(1),PRES_CONV,BOK)
      CALL CALC_CONV_FACT('DIST',UNIT_IN(2),UNIT(2),DIM_CONV,BOK)
      CALL CALC_CONV_FACT('TIME',UNIT_IN(4),UNIT(4),TIME_CONV,BOK)
      CALL CALC_CONV_FACT('RATE',UNIT_IN(5),UNIT(5),RATE_CONV,BOK)
      CALL CALC_CONV_FACT('VISC',UNIT_IN(6),UNIT(6),VISC_CONV,BOK)
      CALL CALC_CONV_FACT('DENS',UNIT_IN(7),UNIT(7),RHO_CONV,BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     READING APERTURE MAP
      CALL READ_AP_MAP(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     INITIALIZING FRACTURE PROPERTIES
      CALL COEF
C
C     CREATING FLOW AND PRESSURE BOUNDARIES
      CALL FLOW_BOUNDARY(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     CLOSING INPUT FILES
      CLOSE(IINP)
      CLOSE(IAPM)
      CALL BLANK
      CALL MESSAGE(" INPUT FILES CLOSED")
C
      RETURN
C
C
 1000 BOK = .FALSE.
C
 2000 FORMAT(5X,'USING AVERAGE LIQUID VISCOSITY IN INP FILE ',G8.6,1X,A)
C
 2010 FORMAT(1X,' ERROR - NONE OR INVAILD VISCOSITY PROVIDED ',G15.6)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE OPEN_IO(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: DEFINES DEFAULT OUPTUT FILE NAMES AND THEN
C         OPENS ALL OF THE INPUT AND OUTPUT FILES.
C
C     LAST MODIFIED: 2016/10/27
C
C     SUBROUTINE CALLS: LNPROC, OPEN_FILE
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       NFLD - NUMBER OF FIELDS IN CFLD AND LFLD AFTER A PROCESSING A LINE
C       OVERWRITE - BOOLEAN VALUE STATING WHETHER TO ALLOW FILES TO BE OVERWITTEN
C       APM - LOGICAL TESTING FOR AN APERTURE MAP INPUT
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C       FLOX_FILE,FLOZ_FILE,FLOM_FILE - FLOW MAP FILE NAMES
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE STRING_MODULE
C
      IMPLICIT NONE
      INTEGER :: I,IFLD,NFLD
      LOGICAL :: BOK,APM,OVERWRITE
      CHARACTER(1) :: SEP
      CHARACTER(MAXLEN) :: PATH
      CHARACTER(MAXLEN) :: SUM_FILE,STAT_FILE,FLOW_FILE,PRESS_FILE
      CHARACTER(MAXLEN) :: MAP_FILE,VTK_FILE
      CHARACTER(MAXLEN) :: FLOX_FILE, FLOZ_FILE, FLOM_FILE
      CHARACTER(MAXLEN) :: STATC_FILE, STATY_FILE
      CHARACTER(MAXLEN),ALLOCATABLE :: OPENED_FILES(:)
C
C     VARIABLE INITIALIZATIONS
      SEP = '/'
      IF (WIN64 == 1) SEP = '\'
      APM = .FALSE.
      OVERWRITE = .FALSE.
      ! INPUT UNIT NUMBERS
      IINP  = 10
      IAPM  = 12
      ! OUTPUT UNIT NUMBERS
      ISTATC = IAPM  + 3
      ISTATY = ISTATC + 1
      IMAP  = ISTATY + 1
      IFLOX = IMAP  + 1
      IFLOZ = IFLOX + 1
      IFLOM = IFLOZ + 1
      IPRES = IFLOM + 1
      IVTK  = IPRES + 1
      !
      ALLOCATE(OPENED_FILES(IVTK))
      OPENED_FILES(:) = ''
C
C     DEFAULT FILE NAMES
      PATH = '.'
      WRITE(SUM_FILE,2100)TRIM(PATH),SEP,'fracture-log.txt'
      WRITE(STAT_FILE,2100)TRIM(PATH),SEP,'fracture-stat.csv'
      WRITE(MAP_FILE,2100)TRIM(PATH),SEP,'fracture-aperture.csv'
      WRITE(FLOW_FILE,2100)TRIM(PATH),SEP,'fracture-flow.csv'
      WRITE(PRESS_FILE,2100)TRIM(PATH),SEP,'fracture-press.csv'
      WRITE(VTK_FILE,2100)TRIM(PATH),SEP,'fracture-data.vtk'
C
C     CHECKING FOR A COMMAND LINE INP FILE TO PARSE
      NFLD = COMMAND_ARGUMENT_COUNT()
      IF (NFLD > 0) THEN
        CALL GET_COMMAND_ARGUMENT(1,MASTER)
        WRITE(*,"(A)") ''
        WRITE(*,"(A)") ' USING SUPPLIED INPUT FILE '//TRIM(MASTER)
      ELSE
        WRITE(*,"(A)") 'FATAL ERROR - NO INPUT FILE SUPPLIED'
        GOTO 1000
      END IF
C
      OPEN(UNIT=IINP,FILE=MASTER,ACTION='READ',STATUS='OLD')
      WRITE(*,"(A)") ''
      WRITE(*,"(A)") ' READING INITIALIZATION FILE'
C
C     READING IN FILE NAMES
      DO
        CALL LNPROC(IINP,MAXFLD,MAXLEN,CVAR,CFLD,LFLD,NFLD,'SAME')
        IF (NFLD == 0) EXIT
        IF (INDEX(CFLD(1),'APER-MAP') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          APM_FILE = CFLD(IFLD)
          APM = .TRUE.
        ELSEIF (INDEX(CFLD(1),'SUMMARY-FILE') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          SUM_FILE = CFLD(IFLD)
        ELSEIF (INDEX(CFLD(1),'STAT-FILE') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          STAT_FILE = CFLD(IFLD)
        ELSEIF (INDEX(CFLD(1),'APER-FILE') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          MAP_FILE = CFLD(IFLD)
        ELSEIF (INDEX(CFLD(1),'FLOW-FILE') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          FLOW_FILE = CFLD(IFLD)
        ELSEIF (INDEX(CFLD(1),'PRESS-FILE') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          PRESS_FILE = CFLD(IFLD)
        ELSEIF (INDEX(CFLD(1),'VTK-FILE') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          VTK_FILE = CFLD(IFLD)
          I = INDEX(VTK_FILE,'.',BACK=.TRUE.)
          CALL LOWER_CASE(VTK_FILE(I:),VTK_FILE(I:))
        ELSEIF (INDEX(CFLD(1),'OVERWRITE') > 0) THEN
          OVERWRITE = .TRUE.
        ELSE
          EXIT
        END IF
      END DO
C
C     OPENING APERTURE MAP
      IF (APM) THEN
        OPEN(UNIT=IAPM,FILE=APM_FILE,STATUS='OLD')
      ELSE
        CVAR = 'FATAL ERROR - NO APERTURE MAP INPUT FILE PROVIDED'
        CALL MESSAGE(CVAR)
        GOTO 1000
      END IF
C
C     CREATING ADDITIONAL FLOW FILES USING ROOT NAME
      I = INDEX(FLOW_FILE,'.', .TRUE.)
      FLOX_FILE = FLOW_FILE(1:I-1)//'-X'//FLOW_FILE(I:)
      FLOZ_FILE = FLOW_FILE(1:I-1)//'-Z'//FLOW_FILE(I:)
      FLOM_FILE = FLOW_FILE(1:I-1)//'-M'//FLOW_FILE(I:)
C
C     CREATING ADDITIONAL STAT FILES USING ROOT NAME
      I = INDEX(STAT_FILE,'.', .TRUE.)
      STATC_FILE = STAT_FILE(1:I)//'csv'
      STATY_FILE = STAT_FILE(1:I)//'yaml'
C
C     OPENING OUTPUT FILES
      CALL OPEN_FILE(IAPM+2,SUM_FILE,OVERWRITE,OPENED_FILES,BOK)
      IOUT  = IAPM + 2 !UPDATING IOUT IF LOG FILE WAS SUCCESSFULLY OPENED
      CALL OPEN_FILE(ISTATC,STATC_FILE,OVERWRITE,OPENED_FILES,BOK)
      CALL OPEN_FILE(ISTATY,STATY_FILE,OVERWRITE,OPENED_FILES,BOK)
      CALL OPEN_FILE(IMAP,MAP_FILE,OVERWRITE,OPENED_FILES,BOK)
      CALL OPEN_FILE(IFLOX,FLOX_FILE,OVERWRITE,OPENED_FILES,BOK)
      CALL OPEN_FILE(IFLOZ,FLOZ_FILE,OVERWRITE,OPENED_FILES,BOK)
      CALL OPEN_FILE(IFLOM,FLOM_FILE,OVERWRITE,OPENED_FILES,BOK)
      CALL OPEN_FILE(IPRES,PRESS_FILE,OVERWRITE,OPENED_FILES,BOK)
      CALL OPEN_FILE(IVTK,VTK_FILE,OVERWRITE,OPENED_FILES,BOK)
      IF (.NOT. BOK) GOTO 1000
C
      CALL MESSAGE('     IO INITIALIZED')
      RETURN
C
  905 CALL INSUFFICIENT_ERROR('FILE NAME')
      CALL MESSAGE(CVAR)
      GOTO 1000
C
 1000 BOK = .FALSE.
      ! REMOVING ANY SUCCESSFULLY OPENED FILES
      DO I = 1,SIZE(OPENED_FILES)
          IF (TRIM(OPENED_FILES(I)) == '') CYCLE
          WRITE(CVAR,2000)TRIM(OPENED_FILES(I))
          CLOSE(I)
          CALL EXECUTE_COMMAND_LINE(CVAR)
      END DO
      !
      RETURN
C
 2000 FORMAT('rm "',A,'"')
C
 2100 FORMAT(A,A,A)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE CLOSE_IO
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: CLOSES ALL OUTPUT FILES
C
C     LAST MODIFIED: 2016/10/12
C
C     SUBROUTINE CALLS: NONE
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      IMPLICIT NONE
C
      CLOSE(ISTATC)
      CLOSE(IMAP)
      CLOSE(IFLOX)
      CLOSE(IFLOZ)
      CLOSE(IFLOM)
      CLOSE(IPRES)
      CLOSE(IVTK)
      !
      CALL BLANK
      CALL MESSAGE(" OUTPUT FILES CLOSED")
      CLOSE(IOUT)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE OPEN_FILE(IUNIT,NAME,OVERWRITE,OPENED_FILES,BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: HANDLES OPENING OF OUPUT FILES WITH ERROR CHECKING
C
C     LAST MODIFIED: 2016/10/27
C
C     SUBROUTINE CALLS: NONE
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       IUNIT - UNIT NUMBER OF FILE TO OPEN
C       IO - ERROR STATUS NUMBER IF OPENING OF FILE FAILS
C       OVERWRITE - BOOLEAN VALUE STATING WHETHER TO ALLOW FILE TO BE OVERWITTEN
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C       STAT - HOW TO OPEN FILE
C       NAME - FILE TO OPEN'S NAME
C       CVAR - GENERAL PURPOSE OUTPUT STRING
C
C ---------------------------------------------------------------------
C
      IMPLICIT NONE
      INTEGER :: IUNIT,IO
      LOGICAL :: OVERWRITE,BOK
      CHARACTER(80)  :: FSTAT
      CHARACTER(300) :: CVAR
      CHARACTER(*)   :: NAME,OPENED_FILES(*)
C
C     SETTING VARS
      FSTAT = 'NEW'
      IF (OVERWRITE) FSTAT = 'REPLACE'
C
C     ATTEMPTING TO OPEN FILE
      IF (OVERWRITE) THEN
        OPEN (UNIT=IUNIT,IOSTAT=IO,FILE=NAME,STATUS=FSTAT,ERR=900)
      ELSE
        OPEN (UNIT=IUNIT,IOSTAT=IO,FILE=NAME,STATUS=FSTAT,ERR=920)
      END IF
      OPENED_FILES(IUNIT) = NAME
C
      RETURN
C
C     FORMATTING
C
  500 FORMAT('IO ERROR: ',I0,' ATTEMPTING TO OPEN: ',A)
C
  600 FORMAT(' SPECIFY "OVERWRITE" IN THE INITIALIZATION ',
     &       'FILE OR USE A DIFFERENT NAME FOR OUTPUT FILE: ',A)
C
  900 WRITE(*,"(1X)")
      WRITE(CVAR,500) IO, TRIM(NAME(1:120))
      WRITE(*,"(A)") CVAR
      GOTO 1000
C
  920 WRITE(*,"(1X)")
      WRITE(*,"('FILE: ',A,' ALREADY EXISTS')") TRIM(NAME(1:120))
      WRITE(CVAR,600) TRIM(NAME)
      WRITE(*,"(A)") CVAR
      GOTO 1000
C
 1000 BOK = .FALSE.
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE READ_MASTER(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: READS THE INITIALIZATION FILE
C
C     LAST MODIFIED: 2016/03/07
C
C     SUBROUTINE CALLS: LNPROC, UNIT_CONV
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       NFLD - NUMBER OF FIELDS IN CFLD AND LFLD AFTER A PROCESSING A LINE
C       OUTPUT_UNIT - BOOLEAN STATING IF OUTPUT UNITS HAVE BEEN DEFINED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE STRING_MODULE
      USE UNIT_CONVERSION_MODULE
C
      IMPLICIT NONE
      INTEGER :: IFLD,NFLD
      LOGICAL :: BOK, OUTPUT_UNIT = .FALSE.
C
      NFLD = SIZE(CFLD)
C
C     READING IN MASTER INPUT FILE
      DO WHILE (NFLD > 0)
        ! READING INITAL FRACTURE PRESSURE
        IF (INDEX(CFLD(1),'FRAC-PRESS') > 0) THEN
          CALL MESSAGE("NOTICE - KEYWORD 'FRAC-PRESS' IS DEPRECATED")
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD),"(F100.0)",ERR = 910) INLPB
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES',UNIT_IN(1),UNIT(1),INLPB,BOK)
        ! READING INLET PRESSURE
        ELSEIF (INDEX(CFLD(1),'INLET-PRESS') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD),"(F100.0)",ERR = 910) INLPB
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES',UNIT_IN(1),UNIT(1),INLPB,BOK)
        ! READING OUTLET PRESSURE
        ELSEIF (INDEX(CFLD(1),'OUTLET-PRES') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD),"(F100.0)",ERR = 910) OUTPB
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES',UNIT_IN(1),UNIT(1),OUTPB,BOK)
        ! READING OUTLET FLOW RATE
        ELSEIF (INDEX(CFLD(1),'OUTLET-RATE') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD),"(F100.0)",ERR = 910) OUTRATE
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_IN(5)
          RATEC = .TRUE.
          CALL CONVERT_VALUE('RATE',UNIT_IN(5),UNIT(5),OUTRATE,BOK)
        ELSEIF (INDEX(CFLD(1),'INLET-RATE') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD),"(F100.0)",ERR = 910) INJRATE
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_IN(5)
          RATEC = .TRUE.
          CALL CONVERT_VALUE('RATE',UNIT_IN(5),UNIT(5),INJRATE,BOK)
        ! READING FLUID DENSITY
        ELSEIF (INDEX(CFLD(1),'FLUID-DENSITY') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD),"(F100.0)",ERR = 910) RHO
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_IN(7)
          CALL CONVERT_VALUE('DENS',UNIT_IN(7),UNIT(7),RHO,BOK)
        ! READING FLUID VISCOSITY
        ELSEIF (INDEX(CFLD(1),'FLUID-VISCOSITY') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD),"(F100.0)",ERR = 910) AVG_VISC
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_IN(6)
          CALL CALC_CONV_FACT('VISC',UNIT_IN(6),UNIT(6),VISC_CONV,BOK)
          CALL CONVERT_VALUE('VISC',UNIT_IN(6),UNIT(6),AVG_VISC,BOK)
        ! READING OUTFLOW SIDE
        ELSEIF (INDEX(CFLD(1),'OUTFLOW-SIDE') > 0) THEN
          CALL MESSAGE("NOTICE - KEYWORD 'OUTFLOW-SIDE' IS DEPRECATED")
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          OUTLET_SIDE = CFLD(IFLD)
        ! READING OUTLET SIDE
        ELSEIF (INDEX(CFLD(1),'OUTLET-SIDE') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          OUTLET_SIDE = CFLD(IFLD)
        ! READING IF TO USE AN OUTFLOW MANIFOLD
        ELSEIF (INDEX(CFLD(1),'MANIFOLD') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          IF (INDEX(CFLD(IFLD),'TRUE') > 0) THEN
             CALL MESSAGE("MANIFOLDS HAVE BEEN DISABLED IN THE MODEL")
          END IF
        ! READING VOXEL SIZE
        ELSEIF (INDEX(CFLD(1),'VOXEL') > 0) THEN
          IFLD = 3
          IF (NFLD < 4) GOTO 905
          READ(CFLD(IFLD),"(F10.0)",ERR = 910) VOX_MET
          CFLD(5) = 'SI'
          CALL CONVERT_VALUE('DIST',CFLD(4),UNIT(2),VOX_MET,BOK)
        ! READING ROUGHNESS COEFFICIENT TO APPLY
        ELSEIF (INDEX(CFLD(1),'ROUGH') > 0) THEN
          IFLD  = 3
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD),"(F10.0)",ERR = 910) R_FACT
        ! READING MAP AVERAGING FACTOR
        ELSEIF (INDEX(CFLD(1),'MAP') > 0) THEN
          IFLD = 4
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD),"(F10.0)",ERR = 910) AVG_FACT
        ! READING IF TO OUTPUT PERCENTILES OF DATA
        ELSEIF (INDEX(CFLD(1),'CALCULATE') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          IF (INDEX(CFLD(2),'PERCENT') > 0) PERCENTILE = .TRUE.
          ! POPULATING PERCENTILE ARRAY
          IF (NFLD >= 3) THEN
            ! REALLOCATING PERCENTILE ARRAY FROM DEFAULT SETTINGS
            DEALLOCATE(PERC_ARR)
            ALLOCATE(PERC_ARR(2,NFLD))
            PERC_ARR(:,:) = 0
            NPCT = NFLD - 2
            DO IFLD = 3,NFLD
              READ(CFLD(IFLD),"(F10.0)",ERR = 910)PERC_ARR(1,IFLD-2)
            END DO
          END IF
        ! READING HIGH MASK TO APPLY TO FRACTURE
        ELSEIF (INDEX(CFLD(1),'HIGH-MASK') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          READ(CFLD(IFLD),*,ERR = 910) HIGH_MASK
        ! READING LOW MASK TO APPLY TO FRACTURE
        ELSEIF (INDEX(CFLD(1),'LOW-MASK') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          READ(CFLD(IFLD),*,ERR = 910) LOW_MASK
        ! READING MAXIMUM MAP DIMENSION
        ELSEIF (INDEX(CFLD(1),'MAXIMUM') > 0) THEN
          IFLD = 4
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD),"(I4)",ERR = 910) MAXDIM
        ! READING SOLVER TYPE
        ELSEIF (INDEX(CFLD(1),'SOLVER') > 0) THEN
          CFLD(2) = TRIM(CFLD(2))
          CALL MESSAGE("ONLY AVAILABLE SOLVER IS D4-GAUSS")
        ! READING OUTPUT UNIT TO CONVERT TO
        ELSEIF (INDEX(CFLD(1),'OUTPUT-UNITS') > 0) THEN
          IF (NFLD < 4) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_OUT(1)
          IFLD = 3
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_OUT(2)
          IFLD = 4
          READ(CFLD(IFLD),"(A)",ERR = 910) UNIT_OUT(5)
          OUTPUT_UNIT = .TRUE.
        ELSE
          CVAR = TRIM(CVAR(1:120)) !SHORTENING LENGTH TO PREVENT OVERFLOW
          CVAR = " ** WARNING: UNRECOGNIZED INPUT: "//TRIM(CVAR)//" **"
          CALL MESSAGE(CVAR)
        END IF
        CALL LNPROC(IINP,MAXFLD,MAXLEN,CVAR,CFLD,LFLD,NFLD)
      END DO
C
C     SETTING OUTPUT UNITS IF NONE PROVIDED
      IF (.NOT. OUTPUT_UNIT) UNIT_OUT = UNIT_IN
C
      RETURN
C
  905 CALL INSUFFICIENT_ERROR("INITIALIZATION")
      CALL MESSAGE(CVAR)
      GOTO 1000
C
  910 CALL FIELD_ERROR("INITIALIZATION",IFLD)
      CALL MESSAGE(CVAR)
      GOTO 1000
C
 1000 BOK = .FALSE.
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE READ_AP_MAP(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: READS AND PROCESSING THE APERTURE MAP DATA
C
C     LAST MODIFIED: 2016/03/07
C
C     SUBROUTINE CALLS: LNPROC, CALC_PERCENTILE, MAP_STATS
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       WIDTH_SORT - AN INDEPENDENT COPY OF THE WIDTH ARRAY USED TO CALCULATE APERTURE PERCENTILES
C       RAW_APER - THE AVERAGE APERATURE OF THE MAP BEFORE AND ROUGHNESS OR MASKING IS PERFORMED
C       MAPLINE - STORES THE CURRENT LINE BEING READ FROM THE APERTURE MAP DATA FILE
C       MAPCFLD - STORES THE FIELDS FROM A LINE IN APERTURE MAP DATA FILE
C       MAPLFLD - STORES THE LENGTHS OF FIELDS FROM A LINE IN THE APERTURE MAP DATA FILE
C       NFLD - NUMBER OF FIELDS IN CFLD AND LFLD AFTER A PROCESSING A LINE
C       ZEROS - NUMBER OF TRUE ZEROS IN THE APERTURE MAP
C       MASK - NUMBER OF CELLS THAT WERE ADJUSTED BY THE HIGH AND LOW MASKS
C       OUTPUT_UNIT - BOOLEAN STATING IF OUTPUT UNITS HAVE BEEN DEFINED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE STRING_MODULE
      USE UNIT_CONVERSION_MODULE
C
      IMPLICIT NONE
      REAL(8), ALLOCATABLE :: WIDTH_SORT(:)
      REAL(8) :: RAW_APER
      INTEGER :: MAPLFLD(MAXDIM+1)
      INTEGER :: IFLD,I,IX,IZ !ITERATORS
      INTEGER :: NFLD,ZEROS,MASK !SIZE/COUNTERS
      CHARACTER(MAXLEN) :: MAPCFLD(MAXDIM+1)
      CHARACTER(100000) :: MAPLINE
      LOGICAL :: BOK
C
      CALL BLANK
      CALL MESSAGE(" READING APERTURE MAP")
      ALLOCATE(AP_MAP(MAXDIM,MAXDIM,0:6))
C
C     FIRST LINE OF AP MAP DATA IS THE BOTTOM OF THE CORE
C     NUM OF RADIAL CELLS = NX, NUM OF LENGTH CELLS = NZ
      NFLD = 0
      NX = 0
      NZ = 0
      AVG_APER = 0
      RAW_APER = 0
      ZEROS = 0
      MASK = 0
      MAX_APER = 0
      MIN_APER = 1000
      AP_MAP(:,:,:) = 0.0
      DO
        NX = NFLD
        CALL LNPROC(IAPM,MAXDIM+1,MAXLEN,MAPLINE,MAPCFLD,MAPLFLD,NFLD)
        IF (NFLD == 0) EXIT
C
        NZ = NZ + 1
        IF (NZ > MAXDIM) GOTO 931
        DO IFLD = 1,NFLD
          IF (NFLD > MAXDIM) GOTO 930
C
          READ(MAPCFLD(IFLD),*,ERR=910) AP_MAP(NZ,IFLD,0)
          RAW_APER = RAW_APER + AP_MAP(NZ,IFLD,0)
C
C         CONDITIONALS USED TO COLLECT DATA ON MAP
          IF (AP_MAP(NZ,IFLD,0) > MAX_APER) MAX_APER = AP_MAP(NZ,IFLD,0)
          IF (AP_MAP(NZ,IFLD,0) < MIN_APER) THEN
            IF (AP_MAP(NZ,IFLD,0) > 0) MIN_APER = AP_MAP(NZ,IFLD,0)
          END IF
          IF (INT(1E9*AP_MAP(NZ,IFLD,0)) .EQ. 0) ZEROS = ZEROS + 1
        END DO
      END DO
      RAW_APER = RAW_APER/(NZ*NX)
C
C     CALCULATING PERCENTILE RANGES OF APERATURES
      IF (PERCENTILE) THEN
        CALL MESSAGE("     CALCULATING APERTURE PERCENTILES OF MAP")
        ALLOCATE(WIDTH_SORT(NX*NZ))
C
C       POPULATING SORTABLE WIDTH ARRAY FROM AP MAP DATA
        I = 0
        DO IZ = 1,NZ
         DO IX = 1,NX
           I = I + 1
           WIDTH_SORT(I) = AP_MAP(IZ,IX,0)
         END DO
        END DO
C
C       CALCULATING PERCENTILES
        CALL CALC_PERCENTILE(WIDTH_SORT,PERC_ARR,NX*NZ,NPCT)
C
        DEALLOCATE(WIDTH_SORT)
      END IF !ENDS PERCENTILE CONDITIONAL
C
C     APPLYING THE HIGH AND LOW MASKS TO THE MAP
      DO IZ = 1,NZ
        DO IX = 1,NX
          ! COUNTING VALUES OUTSIDE OF THE MASKS
          IF (AP_MAP(IZ,IX,0) > HIGH_MASK) MASK = MASK + 1
          IF (AP_MAP(IZ,IX,0) <  LOW_MASK) MASK = MASK + 1
          ! ADJUSTING VALUES OUTSIDE OF THE MASKS
          IF (AP_MAP(IZ,IX,0) > HIGH_MASK) AP_MAP(IZ,IX,0) = HIGH_MASK
          IF (AP_MAP(IZ,IX,0) <  LOW_MASK) AP_MAP(IZ,IX,0) =  LOW_MASK
          AVG_APER = AVG_APER + AP_MAP(IZ,IX,0)
        END DO
      END DO
      AVG_APER = AVG_APER/(NZ*NX)
C
C     GETTING ADDITIONAL STATS ON THE APERTURE MAP
      CALL MESSAGE("     CALCULATING ADDITIONAL MAP STATISTICS")
      CALL MAP_STATS
C
C     CONVERTING CT GRID SIZE TO SI DISTANCES
      CALL ALLOCATE_FRAC(NX,NZ)
      DIAM = NX*VOX_MET*AVG_FACT !MAP AVERAGING ONLY AFFECTS X AND Z DIRECTIONS
      LENG = NZ*VOX_MET*AVG_FACT
      AVG_APER = AVG_APER*VOX_MET
C
C     CALCULATING AVERAGE CORNER VALUES OF CELLS
C     1 = BLC, 2 = BRC, 3 = TRC, 4 = TLC
C     HANDLING CORNERS OF MAP
      AP_MAP(1,1,1)   = AP_MAP(1,1,0)
      AP_MAP(1,NX,2)  = AP_MAP(1,NX,0)
      AP_MAP(NZ,NX,3) = AP_MAP(NZ,NX,0)
      AP_MAP(NZ,1,4)  = AP_MAP(NZ,1,0)
C     CALCULATING CORNER VALUES OF MAP INTERIOR
      DO IZ = 1,NZ-1
        DO IX = 1,NX-1
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,0)
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3) + AP_MAP(IZ+1,IX,0)   !ABOVE
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3) + AP_MAP(IZ,IX+1,0)   !RIGHT
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3) + AP_MAP(IZ+1,IX+1,0) !CORNER
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3)/4.0 !TRC OF CELL
          AP_MAP(IZ+1,IX+1,1) = AP_MAP(IZ,IX,3) !BLC OF CORNER CELL
          AP_MAP(IZ+1,IX,2) = AP_MAP(IZ,IX,3)   !BRC OF ABOVE CELL
          AP_MAP(IZ,IX+1,4) = AP_MAP(IZ,IX,3)   !TLC OF RIGHT CELL
        END DO
      END DO
C     HANDLING LEFT AND RIGHT EDGES OF MAP
      DO IZ = 1,NZ-1
          ! CALCULATING BOTTOM LEFT AND TOP LEFT CORNER OF LEFT EDGE
          AP_MAP(IZ,1,4) = AP_MAP(IZ,1,0)
          AP_MAP(IZ,1,4) = AP_MAP(IZ,1,4) + AP_MAP(IZ+1,1,0)   !ABOVE
          AP_MAP(IZ,1,4) = AP_MAP(IZ,1,4)/2.0 !TLC OF CELL
          AP_MAP(IZ+1,1,1) = AP_MAP(IZ,1,4)   !BLC OF ABOVE CELL
          !
          ! CALCULATING BOTTOM RIGHT AND TOP RIGHT CORNER OF RIGHT EDGE
          AP_MAP(IZ,NX,3) = AP_MAP(IZ,NX,0)
          AP_MAP(IZ,NX,3) = AP_MAP(IZ,NX,3) + AP_MAP(IZ+1,NX,0)   !ABOVE
          AP_MAP(IZ,NX,3) = AP_MAP(IZ,NX,3)/2.0 !TRC OF CELL
          AP_MAP(IZ+1,NX,2) = AP_MAP(IZ,NX,3)   !BRC OF ABOVE CELL
      END DO
C     HANDLING TOP AND BOTTOM EDGES OF MAP
      DO IX = 1,NX-1
          ! CALCULATING BOTTOM LEFT AND BOTTOM RIGHT CORNER OF LOWER EDGE
          AP_MAP(1,IX,2) = AP_MAP(1,IX,0)
          AP_MAP(1,IX,2) = AP_MAP(1,IX,2) + AP_MAP(1,IX+1,0)   !RIGHT
          AP_MAP(1,IX,2) = AP_MAP(1,IX,2)/2.0 !BRC OF CELL
          AP_MAP(1,IX+1,1) = AP_MAP(1,IX,2)   !BLC OF RIGHT CELL
          !
          ! CALCULATING TOP LEFT AND TOP RIGHT CORNER OF UPPER EDGE
          AP_MAP(NZ,IX,3) = AP_MAP(NZ,IX,0)
          AP_MAP(NZ,IX,3) = AP_MAP(NZ,IX,3) + AP_MAP(NZ,IX+1,0)   !RIGHT
          AP_MAP(NZ,IX,3) = AP_MAP(NZ,IX,3)/2.0 !TRC OF CELL
          AP_MAP(NZ,IX+1,4) = AP_MAP(NZ,IX,3)   !TLC OF RIGHT CELL
      END DO
C
C     CREATING AVERAGE WIDTH VECTOR WITH ROUGHNESS ADJUSTMENT
      CVAR = "     CONVERTING 2-D MAP ARRAY IN VOX TO VECTOR IN SI"
      CALL MESSAGE(CVAR)
      WRITE(CVAR,"(5X,'ROUGHNESS FACTOR APPLIED TO MAP ',F10.6)")R_FACT
      CALL MESSAGE(CVAR)
      I = 0
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = I + 1
          ! STORING WIDTH AS THE CENTER CELL VALUE MINUS ROUGHESS
          WIDTH(I) = AP_MAP(IZ,IX,0) - R_FACT
          ! CALCULATING RIGHT FACE (5) AND TOP FACE (6) AVERAGE VALUES MINUS ROUGHNESS
          AP_MAP(IZ,IX,5) = 0.5*(AP_MAP(IZ,IX,2)+AP_MAP(IZ,IX,3))-R_FACT
          AP_MAP(IZ,IX,6) = 0.5*(AP_MAP(IZ,IX,4)+AP_MAP(IZ,IX,3))-R_FACT
          ! APPLYING MASK AFTER ROUGHNESS
          IF (WIDTH(I) <= LOW_MASK) WIDTH(I) = LOW_MASK
          IF (AP_MAP(IZ,IX,5) <= LOW_MASK) AP_MAP(IZ,IX,5) = LOW_MASK
          IF (AP_MAP(IZ,IX,6) <= LOW_MASK) AP_MAP(IZ,IX,6) = LOW_MASK
          ! APPLYING VOXEL TO METER CONVERSION
          WIDTH(I) = WIDTH(I)*VOX_MET
          AP_MAP(IZ,IX,:) = AP_MAP(IZ,IX,:)*VOX_MET
        END DO
      END DO
C
C     OUTPUTTING NUMBER OF ZEROS AND WARNING MESSAGING
      IF (ZEROS > 0) THEN
        WRITE(CVAR,2150) ZEROS
        CALL BLANK
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2155)
        IF (LOW_MASK < 0.0001) CALL MESSAGE(CVAR)
      END IF
C
C     OUTPUTTING DATA ABOUT MAP
      CALL BLANK
      CALL MESSAGE("     PROPERTIES OF APERTURE MAP:")
      CALL BLANK
      WRITE(CVAR,2015)VOX_MET
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2020)AVG_FACT
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2000)'DIAMETER[M]','LENGTH[M]'
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2005) DIAM,LENG,NX,NZ
      CALL MESSAGE(CVAR)
C
      CALL BLANK
      WRITE(CVAR,2100)MASK
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2175)'MINIMUM, NONZERO',MIN_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2175)'MAXIMUM',MAX_APER
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2125)'WITHOUT MASK APPLIED: ',RAW_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2125)'WITH MASK APPLIED:    ',AVG_APER/VOX_MET
      CALL MESSAGE(CVAR)
C
C     OUTPUTTING PERCENTILES IF REQUESTED
      IF (PERCENTILE) THEN
        CALL BLANK
        WRITE(CVAR,2200)
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2225)'PERCENTILE','[VOX]','[MM]'
        CALL MESSAGE(CVAR)
        DO I = 1,NPCT
          WRITE(CVAR,2230)PERC_ARR(1,I),PERC_ARR(2,I),
     &                    PERC_ARR(2,I)*VOX_MET*1000
          CALL MESSAGE(CVAR)
        END DO
      END IF
C
      RETURN
C
C     ERROR HANDLING
C
  910 CALL FIELD_ERROR("APERTURE MAP",IFLD)
      CALL MESSAGE("LINE - "//MAPLINE(1:120)//"...")
      GOTO 1000
C
  930 WRITE(CVAR,2050)'HORIZONTAL',MAXDIM
      CALL MESSAGE(CVAR)
      GOTO 1000
C
  931 WRITE(CVAR,2050)'VERTICAL',MAXDIM
      CALL MESSAGE(CVAR)
      GOTO 1000
C
 1000 BOK = .FALSE.
      RETURN
C
C     LINE FORMATTING
C
 2000 FORMAT(3X,A17,1X,A19,9X,'NX',8X,'NZ')
 2005 FORMAT(5X,F15.6,5X,F15.6,5X,I6.5,4X,I6.5)
C
 2015 FORMAT(9X,'VOXEL TO METER CONVERSION USED: ',E17.6)
 2020 FORMAT(9X,'MAP AVERAGING FACTOR APPLIED: ',F15.6)

C
 2050 FORMAT(1X,'ERROR - MAXIMUM NUMBER OF ',A,' CELLS IS ',I0)
C
 2100 FORMAT(9X,'NUMBER OF CELLS THAT WERE MASKED: ',I0)
C
 2125 FORMAT(9X,'HOMOGENEOUS APERTURE OF FRACTURE ',A22,F15.6,' VOXELS')
C
 2150 FORMAT(5X,'*** WARNING: ',I0,' CELLS HAD AN APERTURE OF ZERO ***')
 2155 FORMAT(5X,'*** WARNING: A LOW MASK OF AT LEAST 0.0001 IS',
     &          ' RECOMMENDED ***')
C
 2175 FORMAT(9X,A,' APERTURE OF FRACTURE: ',F15.6,' VOXELS')
C
 2200 FORMAT(9X,'APERTURE RANGES BY PERCENTILE')
C
 2225 FORMAT(1X,A18,1X,A19,1X,A19)
C
 2230 FORMAT(12X,F7.3,5X,F15.6,5X,F15.9)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE MAP_STATS
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/12/22
C     LAST MODIFIED: 2015/12/31
C
C     PROGRAM DESCRIPTION: THIS PROGRAM CALCULATES VARIOUS STATISTICS
C         ON THE APRETURE MAP BEFORE ANY CONVERSIONS HAVE BEEN APPLIED
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION
C       VARG - HOLDS VARIOGRAM DATA USED TO CALCULATE CORRELATION LENGTH
C       MAX_LEN - LIMITS CORRELTION LENGTH CALCULATIONS TO ONLY APPLY WITHIN A CERTAIN RADIUS
C       APER_VAR - APERTURE DATA VARIANCE
C       SM - USED TO STORE THE SUM OF DIFFERENCES IN VARIANCE CALCULATION
C       SMS - USED TO STORE THE SUM OF DIFFERENCES SQUARED IN VARIANCE CALCULATION
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE UNIT_CONVERSION_MODULE
C
      IMPLICIT NONE
      REAL(8),ALLOCATABLE :: VARG(:,:)
      REAL(8) :: MAX_LEN,APER_VAR,SM,SMS
      REAL(8) :: TEST(3)
      INTEGER :: K,IX,IZ
C
      MAX_LEN = FLOAT(MIN(NX,NZ))/2.0
      ALLOCATE(VARG(0:MAX(NX,NZ),5))
C
C     CALCULATING THE RMS OF THE FRACTURE APERTURE
      APER_RMS = 0.0
      APER_DEV = 0.0
      APER_VAR = 0.0
      SMS = 0.0 !SUM OF DIFFERENCES SQUARED
      SM = 0.0  !SUM OF DIFFERENCES
      DO IZ = 1,NZ
        DO IX = 1,NX
          APER_RMS = APER_RMS + AP_MAP(IZ,IX,0)**2
          SM = SM + (AP_MAP(IZ,IX,0) - AVG_APER)
          SMS = SMS + (AP_MAP(IZ,IX,0) - AVG_APER)**2
        END DO
      END DO
      SM = (SM*SM)*(FLOAT(NX*NZ)**(-1))
      APER_RMS = APER_RMS*FLOAT(NX*NZ)**(-1)
      APER_VAR = (SMS - SM)*(FLOAT(NX*NZ-1)**(-1))
      APER_RMS = SQRT(APER_RMS)*VOX_MET
      APER_DEV = SQRT(APER_VAR)*VOX_MET
C
C     CALCULATING HORIZONTAL VARIOGRAM DATA TO GET X - CORRELATION LENGTH
      VARG(:,:) = 0.0
      TEST(:) = 0.0
      X_CORR = 0.0
      DO K = 1,INT(MAX_LEN)+1
        ! COMPARING TO POINT OFFSET K CELLS RIGHT OF REFERENCE POINT
        DO IX = 1,NX
          DO IZ = 1,NZ
            IF ((IX+K) > NX) CYCLE
            VARG(K,1) = VARG(K,1) + 1
            VARG(K,2) = VARG(K,2)+(AP_MAP(IZ,IX,0)-AP_MAP(IZ,IX+K,0))**2
          END DO
        END DO
        ! CALCULATING AVERAGE LENGTH AND VARIANCE FOR OFFSET K
        IF (VARG(K,1) == 0) CYCLE
        VARG(K,3) =  VARG(K,2)/(VARG(K,1))
        X_CORR = FLOAT(K)*AVG_FACT*VOX_MET
        TEST(1) = ABS(VARG(K,3)/APER_VAR - 0.90)
        IF (VARG(K,3)/APER_VAR > 0.90) THEN
          IF (TEST(2) < TEST(1)) X_CORR = TEST(3)
          EXIT
        END IF
        TEST(2) = TEST(1)
        TEST(3) = X_CORR
      END DO
C
C     CALCULATING VERTICAL VARIOGRAM DATA TO GET Z - CORRELATION LENGTH
      VARG(:,:) = 0.0
      TEST(:) = 0.0
      Z_CORR = 0.0
      DO K = 1,INT(MAX_LEN)+1
        ! COMPARING TO POINT OFFSET K CELLS ABOVE REFERENCE POINT
        DO IX = 1,NX
          DO IZ = 1,NZ
            IF ((IZ+K) > NZ) CYCLE
            VARG(K,1) = VARG(K,1) + 1
            VARG(K,2) = VARG(K,2)+(AP_MAP(IZ,IX,0)-AP_MAP(IZ+K,IX,0))**2
          END DO
        END DO
        ! CALCULATING AVERAGE LENGTH AND VARIANCE FOR OFFSET K
        IF (VARG(K,1) == 0) CYCLE
        VARG(K,3) =  VARG(K,2)/(VARG(K,1))
        Z_CORR = FLOAT(K)*AVG_FACT*VOX_MET
        TEST(1) = ABS(VARG(K,3)/APER_VAR - 0.90)
        IF (VARG(K,3)/APER_VAR > 0.90) THEN
          IF (TEST(2) < TEST(1)) Z_CORR = TEST(3)
          EXIT
        END IF
        TEST(2) = TEST(1)
        TEST(3) = Z_CORR
      END DO
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE CALC_PERCENTILE(VECTOR,PERC_ARR,NVALS,NPCT)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/02/10
C
C     PROGRAM DESCRIPTION: SORTS AND COUNTS THE INPUT VECTOR DUPLICATE VALUES
C      AND THEN CALCULATES PERCENTILES FROM THE DATA
C
C     SUBROUTINE CALLS: HEAP_SORT
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       VECTOR - UNSORTED INPUT VECTOR
C       SORT - COPY OF INPUT VECTOR THAT GET SORTED TO PRESREVE INPUT VECTOR'S ORDER
C       COUNT - STORES THE NUMBER OF TIMES A VALUE APPEARS IN SORT
C       COUNT_VAL - STORES A VERSION OF SORT WITH ALL DUPLICATES REMOVED
C       PERC_ARR - 2-D ARRAY CONTAINING PERCENTILE AND SPOT FOR THE VALUE
C       PERC(1,:) - ALL THE PERCENTILES TO BE CALCULATED
C       PERC(2,:) - ALL OF THE VECTOR VALUES FOR EACH PERCENTILE
C       NVALS -  NUMBER OF VALUES IN VECTOR
C       NPCT - NUMBER OF PERCENTILES TO CALCULATE
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8) :: VECTOR(*),PERC_ARR(2,*)
      REAL(8), ALLOCATABLE :: SORT(:),COUNT(:),COUNT_VAL(:)
      INTEGER :: I,J,K,IV,N,TOT,NVALS,NPCT
C
      ALLOCATE(SORT(NVALS),COUNT(NVALS),COUNT_VAL(NVALS))
      SORT(:) = VECTOR(1:NVALS) !PREVENTS MODIFICATION OF INPUT VECTOR
      COUNT_VAL = 0
C
C     SORTING THE INPUT VECTOR USING THE HEAP SORT METHOD
      CALL HEAP_SORT(SORT,NVALS)
C
C     COUNTING DUPLICATE VALUES AND CREATING A UNIQUE VALUED VECTOR
      IV = 1
      COUNT_VAL(1) = SORT(1)
      COUNT(1:NVALS) = 1
      DO I = 2,NVALS
        IF (COUNT_VAL(IV) .EQ. SORT(I)) THEN
          COUNT(IV) = COUNT(IV) + 1
          CYCLE
        ELSE
          IV = IV + 1
          COUNT_VAL(IV) = SORT(I)
        END IF
      END DO
      N = IV
C
C     CALCULATING PERCENTILES
      DO I = 1,NPCT
        K = CEILING(PERC_ARR(1,I)/100*FLOAT(NVALS))
        TOT = 0
        DO J = 1,N
          TOT = TOT + INT(COUNT(J))
          IF (TOT > K) EXIT
          IF (J == N) EXIT
        END DO
        PERC_ARR(2,I) = COUNT_VAL(J)
      END DO
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE HEAP_SORT(VECTOR,N)
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       VECTOR - UNSORTED INPUT VECTOR
C       VAL - VALUE AT A GIVEN INDEX OF VECTOR
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8) :: VECTOR(*),VAL
      INTEGER :: I,J,L,N,IR
      L = N/2+1
      IR = N
      VAL = -1.0
      ! THE INDEX L WILL BE DECREMENTED FROM ITS INITIAL VALUE DURING THE
      !"HIRING" (HEAP CREATION) PHASE. ONCE IT REACHES 1, THE INDEX IR
      ! WILL BE DECREMENTED FROM ITS INITIAL VALUE DOWN TO 1 DURING THE
      !"RETIREMENT-AND-PROMOTION" (HEAP SELECTION) PHASE.
C
      DO WHILE (IR > 1)
        IF(L > 1)THEN
          L = L-1
          VAL = VECTOR(L)
        ELSE
          VAL = VECTOR(IR)
          VECTOR(IR) = VECTOR(1)
          IR = IR-1
        END IF
C
        I = L
        J = L+L
        DO WHILE (J <= IR)
          IF(J < IR)THEN
            IF(VECTOR(J) < VECTOR(J+1))  J = J+1
          END IF
          !
          IF (VAL < VECTOR(J)) THEN
            VECTOR(I) = VECTOR(J)
            I = J; J = J+J
          ELSE
            J = IR+1
          END IF
        END DO
C
        VECTOR(I) = VAL
      END DO
      VECTOR(1) = VAL
C
      RETURN
      END SUBROUTINE HEAP_SORT
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE COEF
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/10/27
C
C     PROGRAM DESCRIPTION: INIITIALIZES ALL OF THE SIMULATION COEFFICENTS
C
C     SUBROUTINE CALLS: PR_TO_PS, PS_TO_PR
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       PH,PL - PRESSURE INTERPOLATION VARIABLES
C       B - APERTURE OF THE INTERFACE BEING CORRECTED
C       DBP - HALF OF THE DELTA X FROM THE "P" SIDE
C       DBF - HALF OF THE DELTA X FROM THE "F" SIDE
C       THETA - SLOPE ANGLE FROM CENTER OF CELL TO INTERFACE
C       BP3 - TAPERED PLATE CORRECTED "P" APERTURE CUBED
C       BF3 - TAPERED PLATE CORRECTED "F" APERTURE CUBED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
C
      IMPLICIT NONE
      REAL(8) :: B,BF3,BP3,DBF,DBP,W3,THETA
      INTEGER :: I,IX,IZ
C
C     INTIALIZING VARIABLES
      DX(:) = DIAM/NX
      DZ(:) = LENG/NZ
      TRX(:,:) = 0.0
      TRZ(:,:) = 0.0
C
C     DEFINING AN AVERAGE HOMONGENOUS TRANSMISSIVITY
      AVG_TRX = (LENG*AVG_APER**3)/(12.0*DIAM)
      AVG_TRZ = (DIAM*AVG_APER**3)/(12.0*LENG)
C
C     USING THE STOKES TAPERED PLATE FLOW SOLUTION TO CALCULATE THE TRANS
C     OF THE RIGHT AND TOP INTERFACE OF A GRID BLOCK
      DO IZ = 1,NZ
        DO IX = 1,NX-1
          I = (IZ-1)*NX + IX
          !
          ! SOLVING TAPERED PLATE CORRECTION FOR CELL CENTERS TO INTERFACE
          B = AP_MAP(IZ,IX,5) !WIDTH AT INTERFACE BASED ON CORNER VALUES
          DBP = DX(I)/2  !(DX(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
          W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
          BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
          !
          DBF = DX(I+1)/2  !(DX(I+1)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(B-WIDTH(I+1))/DBF)
          W3 = (2 * B**2 * WIDTH(I+1)**2)/(B + WIDTH(I+1))
          BF3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BF3 = W3
          !
          TRX(IZ,IX) = (DBP/BP3 + DBP/BF3)**(-1) * (DZ(I)/12)
        END DO
      END DO
C
      DO IZ = 1,NZ-1
        DO IX = 1,NX
          I = (IZ-1)*NX + IX
          !
          ! SOLVING TAPERED PLATE CORRECTION FOR CELL CENTERS TO INTERFACE
          B = AP_MAP(IZ,IX,6) !WIDTH AT INTERFACE BASED ON CORNER VALUES
          DBP = DZ(I)/2  !(DZ(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
          W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
          BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
          !
          DBF = DZ(I+NX)/2  !(DZ(I+NX)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(B-WIDTH(I+NX))/DBF)
          W3 = (2 * B**2 * WIDTH(I+NX)**2)/(B + WIDTH(I+NX))
          BF3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BF3 = W3
          !
          TRZ(IZ,IX) = (DBP/BP3 + DBP/BF3)**(-1) * (DX(I)/12)
        END DO
      END DO
C
      DO IZ = 1,NZ
        ! HANDLING SPECIAL CASE AT RIGHT SIDE OF FRACTURE
        I = (IZ-1)*NX + NX
        B = AP_MAP(IZ,NX,5) !WIDTH AT INTERFACE BASED ON CORNER VALUES
        DBP = DX(I)/2  !(DX(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
        THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
        W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
        BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
        IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
        !
        TRX(IZ,NX) = (DZ(I)*BP3)/(12.0*DX(I))
      END DO
C
      DO IX = 1,NX
        ! HANDLING SPECIAL CASE AT TOP OF FRACTURE
        I = (NZ-1)*NX + IX
        B = AP_MAP(NZ,IX,6) !WIDTH AT INTERFACE BASED ON CORNER VALUES
        DBP = DZ(I)/2  !(DZ(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
        THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
        W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
        BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
        IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
        !
        TRZ(NZ,IX) = (DZ(I)*BP3)/(12.0*DX(I))
      END DO
C
C     DIVIDING TRANSMISSIVITY BY VISCOSITY
      AVG_TRZ = AVG_TRZ/AVG_VISC
      AVG_TRX = AVG_TRX/AVG_VISC
      TRX(:,:) = TRX(:,:)/AVG_VISC
      TRZ(:,:) = TRZ(:,:)/AVG_VISC
C
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE FLOW_BOUNDARY(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/07/08
C
C     PROGRAM DESCRIPTION: DEFINES FLOW AND PRESSURE BOUNDARY CONIDITIONS
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
C
      IMPLICIT NONE
      INTEGER :: IX,IZ
      LOGICAL :: BOK
C
C
      CALL BLANK
      CALL MESSAGE(" DEFINING BOUNDARY CELL TRANSMISSIBILIES")
C
C     HANDLING EACH OUTFLOW SIDE CASE
      IF (INDEX(OUTLET_SIDE,'LEFT') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 2*TRX(1:NZ,1) !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 2*TRX(1:NZ,NX) !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 0.0 !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 0.0 !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'RIGHT'
        NC = NZ
        DO IZ = 1,NZ
          INLET(IZ) = (IZ-1)*NX + NX
          OUTLET(IZ) = (IZ-1)*NX + 1
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'RIGHT') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 2*TRX(1:NZ,1) !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 2*TRX(1:NZ,NX) !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 0.0 !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 0.0 !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'LEFT'
        NC = NZ
        DO IZ = 1,NZ
          INLET(IZ) = (IZ-1)*NX + 1
          OUTLET(IZ) = (IZ-1)*NX + NX
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'TOP') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 0.0 !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 0.0 !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 2*TRZ(1,1:NX) !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 2*TRZ(NZ,1:NX) !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'BOTTOM'
        NC = NX
        DO IX = 1,NX
          INLET(IX) = IX
          OUTLET(IX) = (NZ-1)*NX + IX
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'BOTTOM') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 0.0 !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 0.0 !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 2*TRZ(1,1:NX) !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 2*TRZ(NZ,1:NX) !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'TOP'
        NC = NX
        DO IX = 1,NX
          INLET(IX) = (NZ-1)*NX + IX
          OUTLET(IX) = IX
        END DO
      ELSE
        GOTO 1000
      END IF
C
      RETURN
C
 1000 BOK = .FALSE.
      CALL MESSAGE(" INVALID OUTLET SIDE ENTERED: "//TRIM(OUTLET_SIDE))
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE MESSAGE(C_OUT)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/07/14
C
C     PROGRAM DESCRIPTION: PRINTS MESSAGES TO SCREEN AND SCREEN LOG FILE
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       C_OUT - STRING TO PRINT
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
C
      IMPLICIT NONE
      CHARACTER(*) :: C_OUT
C
      WRITE(*,'(A)') TRIM(C_OUT)
      IF (IOUT /= 6) WRITE(IOUT,'(A)') TRIM(C_OUT)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE BLANK
C
C     WRITTEN BY: W. NEAL SAMS
C     DATE WRITTEN: 10/04/2013
C
      IMPLICIT NONE
      CHARACTER(1) C1
      DATA C1/' '/
C
      CALL MESSAGE(C1)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE ERROR_WHERE(C_IN)
C
C     WRITTEN BY: W. NEAL SAMS
C     DATE WRITTEN: 03/07/2014
C
      USE APM_MODULE
C
      IMPLICIT NONE
      CHARACTER(*) :: C_IN
      CHARACTER(MAXLEN) :: C_OUT
C
      CALL BLANK
      C_OUT = '     **** ERROR WHILE READING '//TRIM(C_IN)//' DATA ****'
      CALL MESSAGE(C_OUT)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE INSUFFICIENT_ERROR(CHAR_IN)
C
C     WRITTEN BY: W. NEAL SAMS
C     DATE WRITTEN: 03/07/2014
C
      USE APM_MODULE
C
      IMPLICIT NONE
      CHARACTER(*) CHAR_IN
      CHARACTER(MAXLEN) :: C_OUT
C
      CALL ERROR_WHERE(CHAR_IN)
      WRITE(C_OUT,2900)
      CALL MESSAGE(C_OUT)
      RETURN
C
 2900 FORMAT(5X,'**** THE FOLLOWING RECORD CONTAINS INSUFFICIENT '
     &            ,'DATA ****')
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE FIELD_ERROR(CHAR_IN,IFLD)
C
C     WRITTEN BY: W. NEAL SAMS
C     DATE WRITTEN: 03/07/2014
C
      USE APM_MODULE
C
      IMPLICIT NONE
      INTEGER :: IFLD
      CHARACTER(*) CHAR_IN
      CHARACTER(MAXLEN) :: C_OUT
C
      CALL ERROR_WHERE(CHAR_IN)
      WRITE(C_OUT,2900) IFLD
      CALL MESSAGE(C_OUT)
      RETURN
C
 2900 FORMAT(5X,'**** FIELD ',I4,' ON THE FOLLOWING RECORD IS IN '
     &         ,'ERROR ****')
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
C