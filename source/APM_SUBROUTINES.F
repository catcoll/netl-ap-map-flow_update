C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE READ_AP_MAP(BOK, IUNIT)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: READS AND PROCESSING THE APERTURE MAP DATA
C
C     LAST MODIFIED: 2016/03/07
C
C     SUBROUTINE CALLS: LNPROC, CALC_PERCENTILE, MAP_STATS
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       WIDTH_SORT - AN INDEPENDENT COPY OF THE WIDTH ARRAY USED TO CALCULATE APERTURE PERCENTILES
C       RAW_APER - THE AVERAGE APERATURE OF THE MAP BEFORE AND ROUGHNESS OR MASKING IS PERFORMED
C       MAPLINE - STORES THE CURRENT LINE BEING READ FROM THE APERTURE MAP DATA FILE
C       MAPCFLD - STORES THE FIELDS FROM A LINE IN APERTURE MAP DATA FILE
C       MAPLFLD - STORES THE LENGTHS OF FIELDS FROM A LINE IN THE APERTURE MAP DATA FILE
C       NFLD - NUMBER OF FIELDS IN CFLD AND LFLD AFTER A PROCESSING A LINE
C       ZEROS - NUMBER OF TRUE ZEROS IN THE APERTURE MAP
C       MASK - NUMBER OF CELLS THAT WERE ADJUSTED BY THE HIGH AND LOW MASKS
C       OUTPUT_UNIT - BOOLEAN STATING IF OUTPUT UNITS HAVE BEEN DEFINED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE, FIELD_ERROR
      USE STRING_MODULE, ONLY : MAXLEN, LNPROC
      USE UNIT_CONVERSION_MODULE
C
      IMPLICIT NONE
      REAL(8), ALLOCATABLE :: WIDTH_SORT(:)
      REAL(8) :: RAW_APER
      INTEGER :: MAPLFLD(MAXDIM + 1)
      INTEGER :: IUNIT, IFLD,I,IX,IZ !ITERATORS
      INTEGER :: NFLD,ZEROS,MASK !SIZE/COUNTERS
      CHARACTER(MAXLEN) :: CVAR, MAPCFLD(MAXDIM + 1)
      CHARACTER(100000) :: MAPLINE
      LOGICAL :: BOK
C
      CALL BLANK
      CALL MESSAGE(" READING APERTURE MAP")
      ALLOCATE(AP_MAP(MAXDIM, MAXDIM, 0:6))
C
C     FIRST LINE OF AP MAP DATA IS THE BOTTOM OF THE CORE
C     NUM OF RADIAL CELLS = NX, NUM OF LENGTH CELLS = NZ
      NFLD = 0
      NX = 0
      NZ = 0
      AVG_APER = 0
      RAW_APER = 0
      ZEROS = 0
      MASK = 0
      MAX_APER = 0
      MIN_APER = 1000
      AP_MAP(:,:,:) = 0.0
      DO
        NX = NFLD
        CALL LNPROC(IUNIT,MAXDIM+1,MAXLEN,MAPLINE,MAPCFLD,MAPLFLD,NFLD)
        IF (NFLD == 0) EXIT
C
        NZ = NZ + 1
        IF (NZ > MAXDIM) GOTO 931
        DO IFLD = 1,NFLD
          IF (NFLD > MAXDIM) GOTO 930
C
          READ(MAPCFLD(IFLD),*,ERR=910) AP_MAP(NZ,IFLD,0)
          RAW_APER = RAW_APER + AP_MAP(NZ,IFLD,0)
C
C         CONDITIONALS USED TO COLLECT DATA ON MAP
          IF (AP_MAP(NZ,IFLD,0) > MAX_APER) MAX_APER = AP_MAP(NZ,IFLD,0)
          IF (AP_MAP(NZ,IFLD,0) < MIN_APER) THEN
            IF (AP_MAP(NZ,IFLD,0) > 0) MIN_APER = AP_MAP(NZ,IFLD,0)
          END IF
          IF (INT(1E9*AP_MAP(NZ,IFLD,0)) .EQ. 0) ZEROS = ZEROS + 1
        END DO
      END DO
      RAW_APER = RAW_APER/(NZ*NX)
C
C     CLOSING APERTURE MAP FILE
      CLOSE(IUNIT)
C
C     CALCULATING PERCENTILE RANGES OF APERATURES
      IF (PERCENTILE) THEN
        CALL MESSAGE("     CALCULATING APERTURE PERCENTILES OF MAP")
        ALLOCATE(WIDTH_SORT(NX*NZ))
C
C       POPULATING SORTABLE WIDTH ARRAY FROM AP MAP DATA
        I = 0
        DO IZ = 1,NZ
         DO IX = 1,NX
           I = I + 1
           WIDTH_SORT(I) = AP_MAP(IZ,IX,0)
         END DO
        END DO
C
C       CALCULATING PERCENTILES
        CALL CALC_PERCENTILE(WIDTH_SORT,PERC_ARR,NX*NZ,NPCT)
C
        DEALLOCATE(WIDTH_SORT)
      END IF !ENDS PERCENTILE CONDITIONAL
C
C     APPLYING THE HIGH AND LOW MASKS TO THE MAP
      DO IZ = 1,NZ
        DO IX = 1,NX
          ! COUNTING VALUES OUTSIDE OF THE MASKS
          IF (AP_MAP(IZ,IX,0) > HIGH_MASK) MASK = MASK + 1
          IF (AP_MAP(IZ,IX,0) <  LOW_MASK) MASK = MASK + 1
          ! ADJUSTING VALUES OUTSIDE OF THE MASKS
          IF (AP_MAP(IZ,IX,0) > HIGH_MASK) AP_MAP(IZ,IX,0) = HIGH_MASK
          IF (AP_MAP(IZ,IX,0) <  LOW_MASK) AP_MAP(IZ,IX,0) =  LOW_MASK
          AVG_APER = AVG_APER + AP_MAP(IZ,IX,0)
        END DO
      END DO
      AVG_APER = AVG_APER/(NZ*NX)
C
C     GETTING ADDITIONAL STATS ON THE APERTURE MAP
      CALL MESSAGE("     CALCULATING ADDITIONAL MAP STATISTICS")
      CALL MAP_STATS
C
C     CONVERTING CT GRID SIZE TO SI DISTANCES
      CALL ALLOCATE_FRAC(NX,NZ)
      DIAM = NX*VOX_MET*AVG_FACT !MAP AVERAGING ONLY AFFECTS X AND Z DIRECTIONS
      LENG = NZ*VOX_MET*AVG_FACT
      AVG_APER = AVG_APER*VOX_MET
C
C     CALCULATING AVERAGE CORNER VALUES OF CELLS
C     1 = BLC, 2 = BRC, 3 = TRC, 4 = TLC
C     HANDLING CORNERS OF MAP
      AP_MAP(1,1,1)   = AP_MAP(1,1,0)
      AP_MAP(1,NX,2)  = AP_MAP(1,NX,0)
      AP_MAP(NZ,NX,3) = AP_MAP(NZ,NX,0)
      AP_MAP(NZ,1,4)  = AP_MAP(NZ,1,0)
C     CALCULATING CORNER VALUES OF MAP INTERIOR
      DO IZ = 1,NZ-1
        DO IX = 1,NX-1
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,0)
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3) + AP_MAP(IZ+1,IX,0)   !ABOVE
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3) + AP_MAP(IZ,IX+1,0)   !RIGHT
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3) + AP_MAP(IZ+1,IX+1,0) !CORNER
          AP_MAP(IZ,IX,3) = AP_MAP(IZ,IX,3)/4.0 !TRC OF CELL
          AP_MAP(IZ+1,IX+1,1) = AP_MAP(IZ,IX,3) !BLC OF CORNER CELL
          AP_MAP(IZ+1,IX,2) = AP_MAP(IZ,IX,3)   !BRC OF ABOVE CELL
          AP_MAP(IZ,IX+1,4) = AP_MAP(IZ,IX,3)   !TLC OF RIGHT CELL
        END DO
      END DO
C     HANDLING LEFT AND RIGHT EDGES OF MAP
      DO IZ = 1,NZ-1
          ! CALCULATING BOTTOM LEFT AND TOP LEFT CORNER OF LEFT EDGE
          AP_MAP(IZ,1,4) = AP_MAP(IZ,1,0)
          AP_MAP(IZ,1,4) = AP_MAP(IZ,1,4) + AP_MAP(IZ+1,1,0)   !ABOVE
          AP_MAP(IZ,1,4) = AP_MAP(IZ,1,4)/2.0 !TLC OF CELL
          AP_MAP(IZ+1,1,1) = AP_MAP(IZ,1,4)   !BLC OF ABOVE CELL
          !
          ! CALCULATING BOTTOM RIGHT AND TOP RIGHT CORNER OF RIGHT EDGE
          AP_MAP(IZ,NX,3) = AP_MAP(IZ,NX,0)
          AP_MAP(IZ,NX,3) = AP_MAP(IZ,NX,3) + AP_MAP(IZ+1,NX,0)   !ABOVE
          AP_MAP(IZ,NX,3) = AP_MAP(IZ,NX,3)/2.0 !TRC OF CELL
          AP_MAP(IZ+1,NX,2) = AP_MAP(IZ,NX,3)   !BRC OF ABOVE CELL
      END DO
C     HANDLING TOP AND BOTTOM EDGES OF MAP
      DO IX = 1,NX-1
          ! CALCULATING BOTTOM LEFT AND BOTTOM RIGHT CORNER OF LOWER EDGE
          AP_MAP(1,IX,2) = AP_MAP(1,IX,0)
          AP_MAP(1,IX,2) = AP_MAP(1,IX,2) + AP_MAP(1,IX+1,0)   !RIGHT
          AP_MAP(1,IX,2) = AP_MAP(1,IX,2)/2.0 !BRC OF CELL
          AP_MAP(1,IX+1,1) = AP_MAP(1,IX,2)   !BLC OF RIGHT CELL
          !
          ! CALCULATING TOP LEFT AND TOP RIGHT CORNER OF UPPER EDGE
          AP_MAP(NZ,IX,3) = AP_MAP(NZ,IX,0)
          AP_MAP(NZ,IX,3) = AP_MAP(NZ,IX,3) + AP_MAP(NZ,IX+1,0)   !RIGHT
          AP_MAP(NZ,IX,3) = AP_MAP(NZ,IX,3)/2.0 !TRC OF CELL
          AP_MAP(NZ,IX+1,4) = AP_MAP(NZ,IX,3)   !TLC OF RIGHT CELL
      END DO
C
C     CREATING AVERAGE WIDTH VECTOR WITH ROUGHNESS ADJUSTMENT
      CVAR = "     CONVERTING 2-D MAP ARRAY IN VOX TO VECTOR IN SI"
      CALL MESSAGE(CVAR)
      WRITE(CVAR,"(5X,'ROUGHNESS FACTOR APPLIED TO MAP ',F10.6)")R_FACT
      CALL MESSAGE(CVAR)
      I = 0
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = I + 1
          ! STORING WIDTH AS THE CENTER CELL VALUE MINUS ROUGHESS
          WIDTH(I) = AP_MAP(IZ,IX,0) - R_FACT
          ! CALCULATING RIGHT FACE (5) AND TOP FACE (6) AVERAGE VALUES MINUS ROUGHNESS
          AP_MAP(IZ,IX,5) = 0.5*(AP_MAP(IZ,IX,2)+AP_MAP(IZ,IX,3))-R_FACT
          AP_MAP(IZ,IX,6) = 0.5*(AP_MAP(IZ,IX,4)+AP_MAP(IZ,IX,3))-R_FACT
          ! APPLYING MASK AFTER ROUGHNESS
          IF (WIDTH(I) <= LOW_MASK) WIDTH(I) = LOW_MASK
          IF (AP_MAP(IZ,IX,5) <= LOW_MASK) AP_MAP(IZ,IX,5) = LOW_MASK
          IF (AP_MAP(IZ,IX,6) <= LOW_MASK) AP_MAP(IZ,IX,6) = LOW_MASK
          ! APPLYING VOXEL TO METER CONVERSION
          WIDTH(I) = WIDTH(I)*VOX_MET
          AP_MAP(IZ,IX,:) = AP_MAP(IZ,IX,:)*VOX_MET
        END DO
      END DO
C
C     OUTPUTTING NUMBER OF ZEROS AND WARNING MESSAGING
      IF (ZEROS > 0) THEN
        WRITE(CVAR,2150) ZEROS
        CALL BLANK
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2155)
        IF (LOW_MASK < 0.0001) CALL MESSAGE(CVAR)
      END IF
C
C     OUTPUTTING DATA ABOUT MAP
      CALL BLANK
      CALL MESSAGE("     PROPERTIES OF APERTURE MAP:")
      CALL BLANK
      WRITE(CVAR,2015)VOX_MET
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2020)AVG_FACT
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2000)'DIAMETER[M]','LENGTH[M]'
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2005) DIAM,LENG,NX,NZ
      CALL MESSAGE(CVAR)
C
      CALL BLANK
      WRITE(CVAR,2100)MASK
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2175)'MINIMUM, NONZERO',MIN_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2175)'MAXIMUM',MAX_APER
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2125)'WITHOUT MASK APPLIED: ',RAW_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2125)'WITH MASK APPLIED:    ',AVG_APER/VOX_MET
      CALL MESSAGE(CVAR)
C
C     OUTPUTTING PERCENTILES IF REQUESTED
      IF (PERCENTILE) THEN
        CALL BLANK
        WRITE(CVAR,2200)
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2225)'PERCENTILE','[VOX]','[MM]'
        CALL MESSAGE(CVAR)
        DO I = 1,NPCT
          WRITE(CVAR,2230)PERC_ARR(1,I),PERC_ARR(2,I),
     &                    PERC_ARR(2,I)*VOX_MET*1000
          CALL MESSAGE(CVAR)
        END DO
      END IF
C
      RETURN
C
C     ERROR HANDLING
C
  910 CALL FIELD_ERROR("APERTURE MAP",IFLD)
      CALL MESSAGE("LINE - "//MAPLINE(1:120)//"...")
      GOTO 1000
C
  930 WRITE(CVAR,2050)'HORIZONTAL',MAXDIM
      CALL MESSAGE(CVAR)
      GOTO 1000
C
  931 WRITE(CVAR,2050)'VERTICAL',MAXDIM
      CALL MESSAGE(CVAR)
      GOTO 1000
C
 1000 BOK = .FALSE.
      RETURN
C
C     LINE FORMATTING
C
 2000 FORMAT(3X,A17,1X,A19,9X,'NX',8X,'NZ')
 2005 FORMAT(5X,F15.6,5X,F15.6,5X,I6.5,4X,I6.5)
C
 2015 FORMAT(9X,'VOXEL TO METER CONVERSION USED: ',E17.6)
 2020 FORMAT(9X,'MAP AVERAGING FACTOR APPLIED: ',F15.6)

C
 2050 FORMAT(1X,'ERROR - MAXIMUM NUMBER OF ',A,' CELLS IS ',I0)
C
 2100 FORMAT(9X,'NUMBER OF CELLS THAT WERE MASKED: ',I0)
C
 2125 FORMAT(9X,'HOMOGENEOUS APERTURE OF FRACTURE ',A22,F15.6,' VOXELS')
C
 2150 FORMAT(5X,'*** WARNING: ',I0,' CELLS HAD AN APERTURE OF ZERO ***')
 2155 FORMAT(5X,'*** WARNING: A LOW MASK OF AT LEAST 0.0001 IS',
     &          ' RECOMMENDED ***')
C
 2175 FORMAT(9X,A,' APERTURE OF FRACTURE: ',F15.6,' VOXELS')
C
 2200 FORMAT(9X,'APERTURE RANGES BY PERCENTILE')
C
 2225 FORMAT(1X,A18,1X,A19,1X,A19)
C
 2230 FORMAT(12X,F7.3,5X,F15.6,5X,F15.9)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE MAP_STATS
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/12/22
C     LAST MODIFIED: 2015/12/31
C
C     PROGRAM DESCRIPTION: THIS PROGRAM CALCULATES VARIOUS STATISTICS
C         ON THE APRETURE MAP BEFORE ANY CONVERSIONS HAVE BEEN APPLIED
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION
C       VARG - HOLDS VARIOGRAM DATA USED TO CALCULATE CORRELATION LENGTH
C       MAX_LEN - LIMITS CORRELTION LENGTH CALCULATIONS TO ONLY APPLY WITHIN A CERTAIN RADIUS
C       APER_VAR - APERTURE DATA VARIANCE
C       SM - USED TO STORE THE SUM OF DIFFERENCES IN VARIANCE CALCULATION
C       SMS - USED TO STORE THE SUM OF DIFFERENCES SQUARED IN VARIANCE CALCULATION
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE UNIT_CONVERSION_MODULE
C
      IMPLICIT NONE
      REAL(8),ALLOCATABLE :: VARG(:,:)
      REAL(8) :: MAX_LEN,APER_VAR,SM,SMS
      REAL(8) :: TEST(3)
      INTEGER :: K,IX,IZ
C
      MAX_LEN = FLOAT(MIN(NX,NZ))/2.0
      ALLOCATE(VARG(0:MAX(NX,NZ),5))
C
C     CALCULATING THE RMS OF THE FRACTURE APERTURE
      APER_RMS = 0.0
      APER_DEV = 0.0
      APER_VAR = 0.0
      SMS = 0.0 !SUM OF DIFFERENCES SQUARED
      SM = 0.0  !SUM OF DIFFERENCES
      DO IZ = 1,NZ
        DO IX = 1,NX
          APER_RMS = APER_RMS + AP_MAP(IZ,IX,0)**2
          SM = SM + (AP_MAP(IZ,IX,0) - AVG_APER)
          SMS = SMS + (AP_MAP(IZ,IX,0) - AVG_APER)**2
        END DO
      END DO
      SM = (SM*SM)*(FLOAT(NX*NZ)**(-1))
      APER_RMS = APER_RMS*FLOAT(NX*NZ)**(-1)
      APER_VAR = (SMS - SM)*(FLOAT(NX*NZ-1)**(-1))
      APER_RMS = SQRT(APER_RMS)*VOX_MET
      APER_DEV = SQRT(APER_VAR)*VOX_MET
C
C     CALCULATING HORIZONTAL VARIOGRAM DATA TO GET X - CORRELATION LENGTH
      VARG(:,:) = 0.0
      TEST(:) = 0.0
      X_CORR = 0.0
      DO K = 1,INT(MAX_LEN)+1
        ! COMPARING TO POINT OFFSET K CELLS RIGHT OF REFERENCE POINT
        DO IX = 1,NX
          DO IZ = 1,NZ
            IF ((IX+K) > NX) CYCLE
            VARG(K,1) = VARG(K,1) + 1
            VARG(K,2) = VARG(K,2)+(AP_MAP(IZ,IX,0)-AP_MAP(IZ,IX+K,0))**2
          END DO
        END DO
        ! CALCULATING AVERAGE LENGTH AND VARIANCE FOR OFFSET K
        IF (VARG(K,1) == 0) CYCLE
        VARG(K,3) =  VARG(K,2)/(VARG(K,1))
        X_CORR = FLOAT(K)*AVG_FACT*VOX_MET
        TEST(1) = ABS(VARG(K,3)/APER_VAR - 0.90)
        IF (VARG(K,3)/APER_VAR > 0.90) THEN
          IF (TEST(2) < TEST(1)) X_CORR = TEST(3)
          EXIT
        END IF
        TEST(2) = TEST(1)
        TEST(3) = X_CORR
      END DO
C
C     CALCULATING VERTICAL VARIOGRAM DATA TO GET Z - CORRELATION LENGTH
      VARG(:,:) = 0.0
      TEST(:) = 0.0
      Z_CORR = 0.0
      DO K = 1,INT(MAX_LEN)+1
        ! COMPARING TO POINT OFFSET K CELLS ABOVE REFERENCE POINT
        DO IX = 1,NX
          DO IZ = 1,NZ
            IF ((IZ+K) > NZ) CYCLE
            VARG(K,1) = VARG(K,1) + 1
            VARG(K,2) = VARG(K,2)+(AP_MAP(IZ,IX,0)-AP_MAP(IZ+K,IX,0))**2
          END DO
        END DO
        ! CALCULATING AVERAGE LENGTH AND VARIANCE FOR OFFSET K
        IF (VARG(K,1) == 0) CYCLE
        VARG(K,3) =  VARG(K,2)/(VARG(K,1))
        Z_CORR = FLOAT(K)*AVG_FACT*VOX_MET
        TEST(1) = ABS(VARG(K,3)/APER_VAR - 0.90)
        IF (VARG(K,3)/APER_VAR > 0.90) THEN
          IF (TEST(2) < TEST(1)) Z_CORR = TEST(3)
          EXIT
        END IF
        TEST(2) = TEST(1)
        TEST(3) = Z_CORR
      END DO
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE CALC_PERCENTILE(VECTOR,PERC_ARR,NVALS,NPCT)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/02/10
C
C     PROGRAM DESCRIPTION: SORTS AND COUNTS THE INPUT VECTOR DUPLICATE VALUES
C      AND THEN CALCULATES PERCENTILES FROM THE DATA
C
C     SUBROUTINE CALLS: HEAP_SORT
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       VECTOR - UNSORTED INPUT VECTOR
C       SORT - COPY OF INPUT VECTOR THAT GET SORTED TO PRESREVE INPUT VECTOR'S ORDER
C       COUNT - STORES THE NUMBER OF TIMES A VALUE APPEARS IN SORT
C       COUNT_VAL - STORES A VERSION OF SORT WITH ALL DUPLICATES REMOVED
C       PERC_ARR - 2-D ARRAY CONTAINING PERCENTILE AND SPOT FOR THE VALUE
C       PERC(1,:) - ALL THE PERCENTILES TO BE CALCULATED
C       PERC(2,:) - ALL OF THE VECTOR VALUES FOR EACH PERCENTILE
C       NVALS -  NUMBER OF VALUES IN VECTOR
C       NPCT - NUMBER OF PERCENTILES TO CALCULATE
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8) :: VECTOR(*),PERC_ARR(2,*)
      REAL(8), ALLOCATABLE :: SORT(:),COUNT(:),COUNT_VAL(:)
      INTEGER :: I,J,K,IV,N,TOT,NVALS,NPCT
C
      ALLOCATE(SORT(NVALS),COUNT(NVALS),COUNT_VAL(NVALS))
      SORT(:) = VECTOR(1:NVALS) !PREVENTS MODIFICATION OF INPUT VECTOR
      COUNT_VAL = 0
C
C     SORTING THE INPUT VECTOR USING THE HEAP SORT METHOD
      CALL HEAP_SORT(SORT,NVALS)
C
C     COUNTING DUPLICATE VALUES AND CREATING A UNIQUE VALUED VECTOR
      IV = 1
      COUNT_VAL(1) = SORT(1)
      COUNT(1:NVALS) = 1
      DO I = 2,NVALS
        IF (COUNT_VAL(IV) .EQ. SORT(I)) THEN
          COUNT(IV) = COUNT(IV) + 1
          CYCLE
        ELSE
          IV = IV + 1
          COUNT_VAL(IV) = SORT(I)
        END IF
      END DO
      N = IV
C
C     CALCULATING PERCENTILES
      DO I = 1,NPCT
        K = CEILING(PERC_ARR(1,I)/100*FLOAT(NVALS))
        TOT = 0
        DO J = 1,N
          TOT = TOT + INT(COUNT(J))
          IF (TOT > K) EXIT
          IF (J == N) EXIT
        END DO
        PERC_ARR(2,I) = COUNT_VAL(J)
      END DO
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE HEAP_SORT(VECTOR,N)
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       VECTOR - UNSORTED INPUT VECTOR
C       VAL - VALUE AT A GIVEN INDEX OF VECTOR
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8) :: VECTOR(*),VAL
      INTEGER :: I,J,L,N,IR
      L = N/2+1
      IR = N
      VAL = -1.0
      ! THE INDEX L WILL BE DECREMENTED FROM ITS INITIAL VALUE DURING THE
      !"HIRING" (HEAP CREATION) PHASE. ONCE IT REACHES 1, THE INDEX IR
      ! WILL BE DECREMENTED FROM ITS INITIAL VALUE DOWN TO 1 DURING THE
      !"RETIREMENT-AND-PROMOTION" (HEAP SELECTION) PHASE.
C
      DO WHILE (IR > 1)
        IF(L > 1)THEN
          L = L-1
          VAL = VECTOR(L)
        ELSE
          VAL = VECTOR(IR)
          VECTOR(IR) = VECTOR(1)
          IR = IR-1
        END IF
C
        I = L
        J = L+L
        DO WHILE (J <= IR)
          IF(J < IR)THEN
            IF(VECTOR(J) < VECTOR(J+1))  J = J+1
          END IF
          !
          IF (VAL < VECTOR(J)) THEN
            VECTOR(I) = VECTOR(J)
            I = J; J = J+J
          ELSE
            J = IR+1
          END IF
        END DO
C
        VECTOR(I) = VAL
      END DO
      VECTOR(1) = VAL
C
      RETURN
      END SUBROUTINE HEAP_SORT
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE COEF
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/10/27
C
C     PROGRAM DESCRIPTION: INIITIALIZES ALL OF THE SIMULATION COEFFICENTS
C
C     SUBROUTINE CALLS: PR_TO_PS, PS_TO_PR
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       PH,PL - PRESSURE INTERPOLATION VARIABLES
C       B - APERTURE OF THE INTERFACE BEING CORRECTED
C       DBP - HALF OF THE DELTA X FROM THE "P" SIDE
C       DBF - HALF OF THE DELTA X FROM THE "F" SIDE
C       THETA - SLOPE ANGLE FROM CENTER OF CELL TO INTERFACE
C       BP3 - TAPERED PLATE CORRECTED "P" APERTURE CUBED
C       BF3 - TAPERED PLATE CORRECTED "F" APERTURE CUBED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
C
      IMPLICIT NONE
      REAL(8) :: B,BF3,BP3,DBF,DBP,W3,THETA
      INTEGER :: I,IX,IZ
C
C     INTIALIZING VARIABLES
      DX(:) = DIAM/NX
      DZ(:) = LENG/NZ
      TRX(:,:) = 0.0
      TRZ(:,:) = 0.0
C
C     DEFINING AN AVERAGE HOMONGENOUS TRANSMISSIVITY
      AVG_TRX = (LENG*AVG_APER**3)/(12.0*DIAM)
      AVG_TRZ = (DIAM*AVG_APER**3)/(12.0*LENG)
C
C     USING THE STOKES TAPERED PLATE FLOW SOLUTION TO CALCULATE THE TRANS
C     OF THE RIGHT AND TOP INTERFACE OF A GRID BLOCK
      DO IZ = 1,NZ
        DO IX = 1,NX-1
          I = (IZ-1)*NX + IX
          !
          ! SOLVING TAPERED PLATE CORRECTION FOR CELL CENTERS TO INTERFACE
          B = AP_MAP(IZ,IX,5) !WIDTH AT INTERFACE BASED ON CORNER VALUES
          DBP = DX(I)/2  !(DX(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
          W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
          BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
          !
          DBF = DX(I+1)/2  !(DX(I+1)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(B-WIDTH(I+1))/DBF)
          W3 = (2 * B**2 * WIDTH(I+1)**2)/(B + WIDTH(I+1))
          BF3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BF3 = W3
          !
          TRX(IZ,IX) = (DBP/BP3 + DBP/BF3)**(-1) * (DZ(I)/12)
        END DO
      END DO
C
      DO IZ = 1,NZ-1
        DO IX = 1,NX
          I = (IZ-1)*NX + IX
          !
          ! SOLVING TAPERED PLATE CORRECTION FOR CELL CENTERS TO INTERFACE
          B = AP_MAP(IZ,IX,6) !WIDTH AT INTERFACE BASED ON CORNER VALUES
          DBP = DZ(I)/2  !(DZ(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
          W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
          BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
          !
          DBF = DZ(I+NX)/2  !(DZ(I+NX)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(B-WIDTH(I+NX))/DBF)
          W3 = (2 * B**2 * WIDTH(I+NX)**2)/(B + WIDTH(I+NX))
          BF3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BF3 = W3
          !
          TRZ(IZ,IX) = (DBP/BP3 + DBP/BF3)**(-1) * (DX(I)/12)
        END DO
      END DO
C
      DO IZ = 1,NZ
        ! HANDLING SPECIAL CASE AT RIGHT SIDE OF FRACTURE
        I = (IZ-1)*NX + NX
        B = AP_MAP(IZ,NX,5) !WIDTH AT INTERFACE BASED ON CORNER VALUES
        DBP = DX(I)/2  !(DX(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
        THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
        W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
        BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
        IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
        !
        TRX(IZ,NX) = (DZ(I)*BP3)/(12.0*DX(I))
      END DO
C
      DO IX = 1,NX
        ! HANDLING SPECIAL CASE AT TOP OF FRACTURE
        I = (NZ-1)*NX + IX
        B = AP_MAP(NZ,IX,6) !WIDTH AT INTERFACE BASED ON CORNER VALUES
        DBP = DZ(I)/2  !(DZ(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
        THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
        W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
        BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
        IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
        !
        TRZ(NZ,IX) = (DZ(I)*BP3)/(12.0*DX(I))
      END DO
C
C     DIVIDING TRANSMISSIVITY BY VISCOSITY
      AVG_TRZ = AVG_TRZ/AVG_VISC
      AVG_TRX = AVG_TRX/AVG_VISC
      TRX(:,:) = TRX(:,:)/AVG_VISC
      TRZ(:,:) = TRZ(:,:)/AVG_VISC
C
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE FLOW_BOUNDARY(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/07/08
C
C     PROGRAM DESCRIPTION: DEFINES FLOW AND PRESSURE BOUNDARY CONIDITIONS
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE
C
      IMPLICIT NONE
      INTEGER :: IX,IZ
      LOGICAL :: BOK
C
C
      CALL BLANK
      CALL MESSAGE(" DEFINING BOUNDARY CELL TRANSMISSIBILIES")
C
C     HANDLING EACH OUTFLOW SIDE CASE
      IF (INDEX(OUTLET_SIDE,'LEFT') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 2*TRX(1:NZ,1) !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 2*TRX(1:NZ,NX) !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 0.0 !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 0.0 !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'RIGHT'
        NC = NZ
        DO IZ = 1,NZ
          INLET(IZ) = (IZ-1)*NX + NX
          OUTLET(IZ) = (IZ-1)*NX + 1
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'RIGHT') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 2*TRX(1:NZ,1) !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 2*TRX(1:NZ,NX) !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 0.0 !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 0.0 !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'LEFT'
        NC = NZ
        DO IZ = 1,NZ
          INLET(IZ) = (IZ-1)*NX + 1
          OUTLET(IZ) = (IZ-1)*NX + NX
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'TOP') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 0.0 !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 0.0 !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 2*TRZ(1,1:NX) !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 2*TRZ(NZ,1:NX) !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'BOTTOM'
        NC = NX
        DO IX = 1,NX
          INLET(IX) = IX
          OUTLET(IX) = (NZ-1)*NX + IX
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'BOTTOM') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 0.0 !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 0.0 !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 2*TRZ(1,1:NX) !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 2*TRZ(NZ,1:NX) !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'TOP'
        NC = NX
        DO IX = 1,NX
          INLET(IX) = (NZ-1)*NX + IX
          OUTLET(IX) = IX
        END DO
      ELSE
        GOTO 1000
      END IF
C
      RETURN
C
 1000 BOK = .FALSE.
      CALL MESSAGE(" INVALID OUTLET SIDE ENTERED: "//TRIM(OUTLET_SIDE))
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
