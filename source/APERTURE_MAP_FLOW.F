      PROGRAM APERTURE_MAP_FLOW
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTON: RUNS THE LOCAL CUBIC LAW MODEL ON A SUPPLIED
C         FRACTURE APERTURE MAP OUTPUTTING THE DATA TO MULTIPLE CSV FILES
C         AND A VTK FILE FOR USE WITH PARAVIEW. THIS PROGRAM WAS DESIGNED
C         UNDER AN ORISE APPOINTMENT AT THE NATIONAL ENERGY TECHNOLOGY LAB
C         IN MORGANTOWN WEST VIRGINIA.
C
C     DATE WRITTEN:  2016/02/12
C     LAST MODIFIED: 2016/07/10
C
C     SUBROUTINE CALLS: INITIALIZE_RUN, FRAC_FLOW, OUTPUT_DATA, CLOSE_IO
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE, CLOSE_IO
C
      IMPLICIT NONE
      LOGICAL :: BOK = .TRUE.
C
C     INITIALIZING THE MODEL
      CALL INITIALIZE_RUN(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     RUNNING SUBROUTINE TO SOLVE FOR FLOW
      CALL BLANK
      CALL MESSAGE(" CALCULATING FLOW THROUGH FRACTURE")
C
C     SOLVING FOR FLOW THROUGH FRACTURE
      CALL FRAC_FLOW()
      CALL BLANK
      CALL MESSAGE("      FRACTURE FLOWS CALCULATED")
C
C     CALCULATING AND WRITTING OUTPUT DATA
      CALL OUTPUT_DATA(BOK)
C
C     CLOSING OUTPUT FILES
      CALL CLOSE_IO
C
 1000 WRITE(*,"(1X)")
      WRITE(*,"('     **** EXITING PROGRAM ****')")
      IF (.NOT. BOK) STOP(1)
C
      END PROGRAM
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE INITIALIZE_RUN(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: CONTROLS CALLING OF THE MODEL INITALIZATION
C     ROUTINES AND SETS DEFAULT MODEL PARAMETERS.
C
C     SUBROUTINE CALLS: ASSIGN_IO, READ_MASTER, READ_AP_MAP,
C                       COEF, FLOW_BOUNDARY, INIT_OUTPUT
C
C     LAST MODIFIED: 2017/02/05
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : IINP, IAPM, IOUT, OPEN_IO, MESSAGE
      USE MAP_MODULE
      USE STRING_MODULE, ONLY : MAXLEN
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET, CALC_CONV_FACT
C
      IMPLICIT NONE
      LOGICAL :: BOK
      CHARACTER(MAXLEN) :: CVAR
C
C     DEFAULT VALUES
      IOUT = 6 !SETTING TO STDOUT INITIALLY
      ! DEFAULT PERCENTILE SETTINGS
      PERCENTILE = .FALSE.
      ALLOCATE(PERC_ARR(2,9))
      NPCT = 9
      PERC_ARR(1,1:9) = [1,5,10,25,50,75,90,95,99]
      ! DEFAULT TO PRESSURE BOUNDARY CONDITION
      RATEC  = .FALSE.
      PRESC  = .FALSE.
      INLPB    = -1.0
      OUTPB  = -1.0
      OUTRATE = -1.0
      INJRATE = -1.0
      ! DEFAULT LIQUID PROPERIES
      RHO    = 1.0
      AVG_VISC = -1.0
      ! DEFAULT APERTURE MAP PROPERTIES
      MAXDIM    = 500
      AVG_FACT  = 1.0
      R_FACT    = 0.0
      VOX_MET   = 1.0
      HIGH_MASK = 10000.0
      LOW_MASK  = 1E-6
      OUTLET_SIDE   = 'TOP'
      UNIT(:)     = 'SI'
      UNIT_IN(1)  = 'PA'
      UNIT_IN(2)  = 'M'
      UNIT_IN(3)  = 'K'
      UNIT_IN(4)  = 'SEC'
      UNIT_IN(5)  = 'M^3/SEC'
      UNIT_IN(6)  = 'PA*SEC'
      UNIT_IN(7)  = 'KG/M^3'
      UNIT_OUT(1) = 'PA'
      UNIT_OUT(2) = 'M'
      UNIT_OUT(3) = 'K'
      UNIT_OUT(4) = 'SEC'
      UNIT_OUT(5) = 'M^3/SEC'
      UNIT_OUT(6) = 'PA*SEC'
      UNIT_OUT(7) = 'KG/M^3'
C
C     INITIALIZING IO
      CALL OPEN_IO(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     READING INPUT FILE
      CALL READ_MASTER(BOK, IINP)
      IF (.NOT. BOK) GOTO 1000
C
C     CHECKING IF BOTH INLET AND OUTLET PRESSURE CONDITION WERE SUPPLIED
      IF ((INLPB .GE. 0) .AND. (OUTPB .GE. 0)) THEN
        PRESC = .TRUE.
        CALL MESSAGE("     FRACTURE FLOW IS PRESSURE CONTROLLED")
      ELSE
        PRESC = .FALSE.
        CALL MESSAGE("     FRACTURE FLOW IS RATE CONTROLLED")
      END IF
C
C     CHECKING VISCOSITY VALUE PROVIDED
      IF (AVG_VISC > 0) THEN
        WRITE(CVAR,2000) AVG_VISC/VISC_CONV,TRIM(UNIT_IN(6))
        CALL MESSAGE(CVAR)
      ELSE
        WRITE(CVAR,2010) AVG_VISC/VISC_CONV
        CALL MESSAGE(CVAR)
        GOTO 1000
      END IF
C
C     SETTING CONVERSION VALUES
      CALL CALC_CONV_FACT('PRES',UNIT_IN(1),UNIT(1),PRES_CONV,BOK)
      CALL CALC_CONV_FACT('DIST',UNIT_IN(2),UNIT(2),DIM_CONV,BOK)
      CALL CALC_CONV_FACT('TIME',UNIT_IN(4),UNIT(4),TIME_CONV,BOK)
      CALL CALC_CONV_FACT('RATE',UNIT_IN(5),UNIT(5),RATE_CONV,BOK)
      CALL CALC_CONV_FACT('VISC',UNIT_IN(6),UNIT(6),VISC_CONV,BOK)
      CALL CALC_CONV_FACT('DENS',UNIT_IN(7),UNIT(7),RHO_CONV,BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     READING APERTURE MAP
      CALL READ_AP_MAP(IAPM, BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     INITIALIZING FRACTURE PROPERTIES
      CALL COEF
C
C     CREATING FLOW AND PRESSURE BOUNDARIES
      CALL FLOW_BOUNDARY(BOK)
      IF (.NOT. BOK) GOTO 1000
C
      RETURN
C
C
 1000 BOK = .FALSE.
C
 2000 FORMAT(5X,'AVERAGE LIQUID VISCOSITY USED ',G12.6,1X,A)
C
 2010 FORMAT(1X,'ERROR - NONE OR INVAILD VISCOSITY PROVIDED ',G15.6)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE READ_MASTER(BOK, IUNIT)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: READS THE INITIALIZATION FILE
C
C     LAST MODIFIED: 2016/03/07
C
C     SUBROUTINE CALLS: LNPROC, UNIT_CONV
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       NFLD - NUMBER OF FIELDS IN CFLD AND LFLD AFTER A PROCESSING A LINE
C       OUTPUT_UNIT - BOOLEAN STATING IF OUTPUT UNITS HAVE BEEN DEFINED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : MESSAGE, INSUFFICIENT_ERROR, FIELD_ERROR
      USE MAP_MODULE, ONLY : AVG_FACT,MAXDIM,HIGH_MASK,LOW_MASK,R_FACT
      USE STRING_MODULE, ONLY : MAXFLD, MAXLEN, LNPROC
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET,
     &                                   CONVERT_VALUE, CALC_CONV_FACT
C
      IMPLICIT NONE
      INTEGER :: IUNIT, IFLD, NFLD, LFLD(MAXFLD)
      LOGICAL :: BOK, OUTPUT_UNIT = .FALSE.
      CHARACTER(MAXLEN) :: CVAR, CFLD(MAXFLD)
C
C     READING IN MASTER INPUT FILE
      CALL LNPROC(IUNIT, MAXFLD, MAXLEN, CVAR, CFLD, LFLD, NFLD)
      DO WHILE (NFLD > 0)
        ! DEPRECATED KEYWORDS
        ! READING INITAL FRACTURE PRESSURE
        IF (INDEX(CFLD(1), 'FRAC-PRESS') > 0) THEN
          CALL MESSAGE("NOTICE - KEYWORD 'FRAC-PRESS' IS DEPRECATED")
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) INLPB
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES', UNIT_IN(1), UNIT(1), INLPB, BOK)
        ! READING OUTFLOW SIDE
        ELSEIF (INDEX(CFLD(1), 'OUTFLOW-SIDE') > 0) THEN
          CALL MESSAGE("NOTICE - KEYWORD 'OUTFLOW-SIDE' IS DEPRECATED")
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          OUTLET_SIDE = CFLD(IFLD)
        !
        ! READING INLET PRESSURE
        ELSEIF (INDEX(CFLD(1), 'INLET-PRESS') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) INLPB
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES', UNIT_IN(1), UNIT(1), INLPB, BOK)
        ! READING OUTLET PRESSURE
        ELSEIF (INDEX(CFLD(1), 'OUTLET-PRES') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) OUTPB
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES', UNIT_IN(1), UNIT(1), OUTPB, BOK)
        ! READING OUTLET FLOW RATE
        ELSEIF (INDEX(CFLD(1), 'OUTLET-RATE') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) OUTRATE
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(5)
          RATEC = .TRUE.
          CALL CONVERT_VALUE('RATE', UNIT_IN(5), UNIT(5), OUTRATE, BOK)
        ELSEIF (INDEX(CFLD(1), 'INLET-RATE') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) INJRATE
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(5)
          RATEC = .TRUE.
          CALL CONVERT_VALUE('RATE', UNIT_IN(5), UNIT(5), INJRATE, BOK)
        ! READING FLUID DENSITY
        ELSEIF (INDEX(CFLD(1), 'FLUID-DENSITY') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) RHO
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(7)
          CALL CONVERT_VALUE('DENS', UNIT_IN(7), UNIT(7), RHO, BOK)
        ! READING FLUID VISCOSITY
        ELSEIF (INDEX(CFLD(1), 'FLUID-VISCOSITY') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) AVG_VISC
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(6)
          CALL CALC_CONV_FACT('VISC',UNIT_IN(6),UNIT(6),VISC_CONV,BOK)
          CALL CONVERT_VALUE('VISC', UNIT_IN(6), UNIT(6), AVG_VISC, BOK)
        ! READING OUTLET SIDE
        ELSEIF (INDEX(CFLD(1), 'OUTLET-SIDE') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          OUTLET_SIDE = CFLD(IFLD)
        ! READING VOXEL SIZE
        ELSEIF (INDEX(CFLD(1), 'VOXEL') > 0) THEN
          IFLD = 3
          IF (NFLD < 4) GOTO 905
          READ(CFLD(IFLD), "(F10.0)", ERR = 910) VOX_MET
          CFLD(5) = 'SI'
          CALL CONVERT_VALUE('DIST', CFLD(4), UNIT(2), VOX_MET, BOK)
        ! READING ROUGHNESS COEFFICIENT TO APPLY
        ELSEIF (INDEX(CFLD(1), 'ROUGH') > 0) THEN
          IFLD  = 3
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F10.0)", ERR = 910) R_FACT
        ! READING MAP AVERAGING FACTOR
        ELSEIF (INDEX(CFLD(1), 'MAP') > 0) THEN
          IFLD = 4
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F10.0)", ERR = 910) AVG_FACT
        ! READING IF TO OUTPUT PERCENTILES OF DATA
        ELSEIF (INDEX(CFLD(1), 'CALCULATE') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          IF (INDEX(CFLD(2), 'PERCENT') > 0) PERCENTILE = .TRUE.
          ! POPULATING PERCENTILE ARRAY
          IF (NFLD >= 3) THEN
            ! REALLOCATING PERCENTILE ARRAY FROM DEFAULT SETTINGS
            DEALLOCATE(PERC_ARR)
            ALLOCATE(PERC_ARR(2, NFLD))
            PERC_ARR(:, :) = 0
            NPCT = NFLD - 2
            DO IFLD = 3, NFLD
              READ(CFLD(IFLD), "(F10.0)", ERR = 910)PERC_ARR(1, IFLD-2)
            END DO
          END IF
        ! READING HIGH MASK TO APPLY TO FRACTURE
        ELSEIF (INDEX(CFLD(1), 'HIGH-MASK') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          READ(CFLD(IFLD), *, ERR = 910) HIGH_MASK
        ! READING LOW MASK TO APPLY TO FRACTURE
        ELSEIF (INDEX(CFLD(1), 'LOW-MASK') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          READ(CFLD(IFLD), *, ERR = 910) LOW_MASK
        ! READING MAXIMUM MAP DIMENSION
        ELSEIF (INDEX(CFLD(1), 'MAXIMUM') > 0) THEN
          IFLD = 4
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(I4)", ERR = 910) MAXDIM
        ! READING OUTPUT UNIT TO CONVERT TO
        ELSEIF (INDEX(CFLD(1), 'OUTPUT-UNITS') > 0) THEN
          IF (NFLD < 4) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_OUT(1)
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_OUT(2)
          IFLD = 4
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_OUT(5)
          OUTPUT_UNIT = .TRUE.
        ELSE
          CVAR = TRIM(CVAR(1:120)) !SHORTENING LENGTH TO PREVENT OVERFLOW
          CVAR = " ** WARNING: UNRECOGNIZED INPUT: "//TRIM(CVAR)//" **"
          CALL MESSAGE(CVAR)
        END IF
        CALL LNPROC(IUNIT, MAXFLD, MAXLEN, CVAR, CFLD, LFLD, NFLD)
      END DO
C
C     SETTING OUTPUT UNITS IF NONE PROVIDED
      IF (.NOT. OUTPUT_UNIT) UNIT_OUT = UNIT_IN
C
C     CLOSING INPUT FILES
      CLOSE(IUNIT)
C
      RETURN
C
  905 CALL INSUFFICIENT_ERROR("INITIALIZATION")
      CALL MESSAGE(CVAR)
      GOTO 1000
C
  910 CALL FIELD_ERROR("INITIALIZATION", IFLD)
      CALL MESSAGE(CVAR)
      GOTO 1000
C
 1000 BOK = .FALSE.
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE READ_AP_MAP(IUNIT, BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: READS AND PROCESSING THE APERTURE MAP DATA
C
C     LAST MODIFIED: 2017/02/08
C
C     SUBROUTINE CALLS: LNPROC, CALC_PERCENTILE, MAP_STATS
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       RAW_APER - THE AVERAGE APERATURE OF THE MAP BEFORE AND ROUGHNESS OR MASKING IS PERFORMED
C       ZEROS - NUMBER OF TRUE ZEROS IN THE APERTURE MAP
C       MASK - NUMBER OF CELLS THAT WERE ADJUSTED BY THE HIGH AND LOW MASKS
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE
      USE MAP_MODULE
      USE STRING_MODULE, ONLY : MAXLEN
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET
C
      IMPLICIT NONE
      REAL(8), ALLOCATABLE :: DATA_MAP(:,:)
      REAL(8) :: RAW_APER, STAT_VALS(4)
      INTEGER :: IUNIT,I,IX,IZ !ITERATORS
      INTEGER :: ZEROS,MASK !SIZE/COUNTERS
      CHARACTER(MAXLEN) :: STAT_KEYS(4), CVAR
      LOGICAL :: BOK
C
C     FIRST LINE OF AP MAP DATA IS THE BOTTOM OF THE CORE
C     NUM OF RADIAL CELLS = NX, NUM OF LENGTH CELLS = NZ
      CALL BLANK
      CALL MESSAGE(" READING APERTURE MAP")
      CALL READ_DATA_MAP(DATA_MAP, IUNIT, BOK)
      CLOSE(IUNIT)
      CALL ALLOCATE_MAP
      CALL ALLOCATE_FRAC(NX, NZ)
      AP_MAP(:, :) = DATA_MAP(:, :)
      DEALLOCATE(DATA_MAP)
C
C     CONVERTING CT GRID SIZE TO SI DISTANCES
      ! MAP AVERAGING ONLY AFFECTS X AND Z DIRECTIONS
      DIAM = NX * VOX_MET * AVG_FACT
      LENG = NZ * VOX_MET * AVG_FACT
C
C     CALCULATING PERCENTILE RANGES OF APERTURES
      IF (PERCENTILE) THEN
        ! WARNING: ONLY USING RESHAPE BECAUSE ORDER DOESN'T MATTER HERE
        WIDTH = RESHAPE(AP_MAP, [NX*NZ])
        CALL CALC_PERCENTILE(WIDTH, PERC_ARR, NX*NZ, NPCT)
      END IF !ENDS PERCENTILE CONDITIONAL
C
C     COLLECTING MAP STATS AND MASKING CELLS
      RAW_APER = SUM(AP_MAP) / (NX * NZ)
      ZEROS = COUNT(INT(AP_MAP * 1E9) == 0)
      MAX_APER = MAXVAL(AP_MAP)
      MIN_APER = MINVAL(AP_MAP, MASK=AP_MAP > 0)
      MASK = COUNT(AP_MAP > HIGH_MASK) + COUNT(AP_MAP < LOW_MASK)
      DO IZ = 1, NZ
        DO IX = 1, NX
          !
          ! ADJUSTING VALUES OUTSIDE OF THE MASKS
          IF (AP_MAP(IZ,IX) > HIGH_MASK) AP_MAP(IZ,IX) = HIGH_MASK
          IF (AP_MAP(IZ,IX) <  LOW_MASK) AP_MAP(IZ,IX) = LOW_MASK
        END DO
      END DO
      AVG_APER = SUM(AP_MAP) / (NZ * NX) * VOX_MET
C
C     CREATING POINT MAP
      CALL CREATE_POINT_MAP(AP_MAP, AP_POINT_MAP)
C
C     CREATING AVERAGE WIDTH VECTOR WITH ROUGHNESS ADJUSTMENT
      CVAR = "     CONVERTING 2-D MAP ARRAY IN VOX TO VECTOR IN SI"
      CALL MESSAGE(CVAR)
      WRITE(CVAR,"(5X,'ROUGHNESS FACTOR APPLIED TO MAP ',F10.6)")R_FACT
      CALL MESSAGE(CVAR)
      !
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ - 1) * NX + IX
          ! STORING WIDTH AS THE CENTER CELL VALUE MINUS ROUGHESS
          WIDTH(I) = AP_MAP(IZ,IX) - R_FACT
          ! CALCULATING RIGHT FACE (5) AND TOP FACE (6) AVERAGE VALUES MINUS ROUGHNESS
          AP_POINT_MAP(IZ,IX,5) = 0.5*(AP_POINT_MAP(IZ,IX,2) +
     &                                 AP_POINT_MAP(IZ,IX,3)) - R_FACT
          AP_POINT_MAP(IZ,IX,6) = 0.5*(AP_POINT_MAP(IZ,IX,4) +
     &                                 AP_POINT_MAP(IZ,IX,3)) - R_FACT
          !
          ! CHECKING MASK AFTER ROUGHNESS FACTOR
          IF (WIDTH(I) < LOW_MASK) WIDTH(I) = LOW_MASK
          !
          IF (AP_POINT_MAP(IZ,IX,5) < LOW_MASK) THEN
            AP_POINT_MAP(IZ,IX,5) = LOW_MASK
          END IF
          !
          IF (AP_POINT_MAP(IZ,IX,6) < LOW_MASK) THEN
             AP_POINT_MAP(IZ,IX,6) = LOW_MASK
          END IF
        END DO
      END DO
      WIDTH(:) = WIDTH(:) * VOX_MET
      AP_MAP(:, :) = AP_MAP(:, :) * VOX_MET
      AP_POINT_MAP(:, :, :) =   AP_POINT_MAP(:, :, :) * VOX_MET
C
C     GETTING ADDITIONAL STATS ON THE APERTURE MAP
      CALL MESSAGE("     CALCULATING ADDITIONAL MAP STATISTICS")
      CALL MAP_STATS(AP_MAP, STAT_KEYS, STAT_VALS)
      APER_RMS = STAT_VALS(1)
      APER_DEV = STAT_VALS(2)
      X_CORR = STAT_VALS(3) * AVG_FACT * VOX_MET
      Z_CORR = STAT_VALS(4) * AVG_FACT * VOX_MET
C
C     OUTPUTING NUMBER OF ZEROS AND WARNING MESSAGING
      IF (ZEROS > 0) THEN
        WRITE(CVAR,2150) ZEROS
        CALL BLANK
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2155)
        IF (LOW_MASK < 0.0001) CALL MESSAGE(CVAR)
      END IF
C
C     OUTPUTTING DATA ABOUT MAP
      CALL BLANK
      CALL MESSAGE("     PROPERTIES OF APERTURE MAP:")
      CALL BLANK
      WRITE(CVAR,2015) VOX_MET
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2020) AVG_FACT
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2000)'DIAMETER[M]','LENGTH[M]'
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2005) DIAM,LENG,NX,NZ
      CALL MESSAGE(CVAR)
C
      CALL BLANK
      WRITE(CVAR,2100)MASK
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2175)'MINIMUM, NONZERO',MIN_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2175)'MAXIMUM',MAX_APER
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2125)'WITHOUT MASK APPLIED: ',RAW_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2125)'WITH MASK APPLIED:    ',AVG_APER/VOX_MET
      CALL MESSAGE(CVAR)
C
C     OUTPUTTING PERCENTILES IF REQUESTED
      IF (PERCENTILE) THEN
        CALL BLANK
        WRITE(CVAR,2200)
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2225)'PERCENTILE','[VOX]','[MM]'
        CALL MESSAGE(CVAR)
        DO I = 1,NPCT
          WRITE(CVAR,2230)PERC_ARR(1,I),PERC_ARR(2,I),
     &                    PERC_ARR(2,I)*VOX_MET*1000
          CALL MESSAGE(CVAR)
        END DO
      END IF
C
      RETURN
C
C     LINE FORMATTING
C
 2000 FORMAT(3X,A17,1X,A19,9X,'NX',8X,'NZ')
 2005 FORMAT(5X,F15.6,5X,F15.6,5X,I6.5,4X,I6.5)
C
 2015 FORMAT(9X,'VOXEL TO METER CONVERSION USED: ',E17.6)
 2020 FORMAT(9X,'MAP AVERAGING FACTOR APPLIED: ',F15.6)
C
 2100 FORMAT(9X,'NUMBER OF CELLS THAT WERE MASKED: ',I0)
C
 2125 FORMAT(9X,'HOMOGENEOUS APERTURE OF FRACTURE ',A22,F15.6,' VOXELS')
C
 2150 FORMAT(5X,'*** WARNING: ',I0,' CELLS HAD AN APERTURE OF ZERO ***')
 2155 FORMAT(5X,'*** WARNING: A LOW MASK OF AT LEAST 0.0001 IS',
     &          ' RECOMMENDED ***')
C
 2175 FORMAT(9X,A,' APERTURE OF FRACTURE: ',F15.6,' VOXELS')
C
 2200 FORMAT(9X,'APERTURE RANGES BY PERCENTILE')
C
 2225 FORMAT(1X,A18,1X,A19,1X,A19)
C
 2230 FORMAT(12X,F7.3,5X,F15.6,5X,F15.9)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE SOLVER
C
C     WRITTEN BY: MATTHEW STADELMAN
C     LAST MODIFIED: 2017/02/06
C
C     SUBROUTINE DESCRIPTION: CREATES THE COEFFICENT MATRIX AND SOLVES FOR THE
C         PRESSURE.
C
C     SUBROUTINE CALLS: ALLOCATE_COEF,DEFINE_BOUNDARY_CONDITINS,
C                       D4_REORDER, D4_SOLVER, DEALLOCATE_COEFF
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       X - STORES THE FINAL SOLUTIONS TO THE LINEAR SYSTEM
C       NEUMANNG_X - STORES THE SOLUTION TO THE GROUP BC CELL
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE D4_SOLVER_MODULE, ONLY : CC, TT, INIT_SOLVER, D4_SOLVER,
     &                             ADD_DIRICHLET_BOUND_COND,
     &                             ADD_NUEMANNG_BOUND_COND
      USE IO_MODULE, ONLY : BLANK, MESSAGE
      USE MAP_MODULE, ONLY : NX, NZ
C
      IMPLICIT NONE
      REAL(8) :: NEUMANNG_X, ST, EN
      REAL(8), ALLOCATABLE :: X(:)
      INTEGER :: I,IX,IZ
      CHARACTER(80) :: CVAR
C
C     INITIALIZING SOLVER
      CALL INIT_SOLVER(NX, NZ)
C
C     SWEEPING GRID TO POPULATE COEFFICIENT ARRAYS
      I = 0
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ-1)*NX + IX
          TT(I,1) = -TRX(IZ,IX-1) !LEFT
          TT(I,2) = -TRX(IZ,IX)   !RIGHT
          TT(I,3) = -TRZ(IZ-1,IX) !DOWN
          TT(I,4) = -TRZ(IZ,IX)   !TOP
          CC(I) = -SUM(TT(I,:))
        END DO
      END DO
C
C     SETTING PRESSURE BCs
      IF (OUTPB .GE. 0) THEN
        CALL ADD_DIRICHLET_BOUND_COND(OUTLET_SIDE, OUTPB)
      END IF
      !
      IF (INLPB .GE. 0) THEN
        CALL ADD_DIRICHLET_BOUND_COND(INLET_SIDE, INLPB)
      END IF
C
C     DEFINING GROUP FLOW BCs
      IF (INJRATE .GT. 0.0) THEN !INLET FLOW RATE BC
        CALL ADD_NUEMANNG_BOUND_COND(INLET_SIDE, INJRATE)
      END IF
      !
      IF (OUTRATE .GT. 0.0) THEN !OUTLET FLOW RATE BC
        CALL ADD_NUEMANNG_BOUND_COND(OUTLET_SIDE, -OUTRATE)
      END IF
C
C
C     CALLING THE SOLVER ALGORITHM
      CALL BLANK
      CALL MESSAGE('     USING D4 GAUSS SOLVER')
      CALL CPU_TIME(ST)
      CALL D4_SOLVER(X, NEUMANNG_X)
      CALL CPU_TIME(EN)
      WRITE(CVAR,"(5X,'REQUIRED TIME FOR SOLUTION: ',F13.6)")(EN-ST)
      CALL MESSAGE(CVAR)
C
C     UPDATING THE FRACTURE PRESSURE
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ - 1)*NX + IX
          FRAC_PR(IZ,IX) = X(I)
        END DO
      END DO
C
C     SETTING FLOW RATE DETERMINED INLET OR OUTLET PRESSURE
      IF (.NOT. PRESC) THEN
        IF (INJRATE .GT. 0.0) THEN !INLET FLOW RATE BC
          INLPB = NEUMANNG_X
        END IF
        !
        IF (OUTRATE .GT. 0.0) THEN !OUTLET FLOW RATE BC
          OUTPB = NEUMANNG_X
        END IF
      END IF
C
C
      DEALLOCATE(X)
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C

      SUBROUTINE FRAC_FLOW
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2017/02/06
C
C     PROGRAM DESCRIPTION: SOLVES FOR THE STEADY STATE FLOW THROUGH A
C         FRACTURE.
C
C     SUBROUTINE CALLS: SOLVER
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       Q(1:4,:) - STORES THE STEADY STATE FLOW THROUGH A CELL IN ORDER OF LEFT,RIGHT,BOTTON,TOP
C       Q(5,:) - STORES THE FINAL NET MASS GAIN/LOSS FOR A CELL
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE MAP_MODULE, ONLY : NX, NZ
C
      IMPLICIT NONE
      INTEGER :: I,IX,IZ
C
C     SOLVING FOR STEADY STATE FLOW PRESSURE DISTRIBUTION
      CALL SOLVER
C
C     HANDLING EACH OUTFLOW SIDE CASE TO SET BOUNDARY PRESSURES
      IF (INDEX(OUTLET_SIDE,'LEFT') > 0) THEN
        FRAC_PR(:,0) = OUTPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = INLPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = INLPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = INLPB !EXTRA TOP ROW
      ELSE IF (INDEX(OUTLET_SIDE,'RIGHT') > 0) THEN
        FRAC_PR(:,0) = INLPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = OUTPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = INLPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = INLPB !EXTRA TOP ROW
      ELSE IF (INDEX(OUTLET_SIDE,'TOP') > 0) THEN
        FRAC_PR(:,0) = INLPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = INLPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = INLPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = OUTPB !EXTRA TOP ROW
      ELSE IF (INDEX(OUTLET_SIDE,'BOTTOM') > 0) THEN
        FRAC_PR(:,0) = INLPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = INLPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = OUTPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = INLPB !EXTRA TOP ROW
      END IF
C
C     CALCULATING THE FINAL FLOW RATES FOR CELLS IN THE FRACTURE
      Q(:,:) = 0.0
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ-1)*NX+IX
          Q(1,I) = -TRX(IZ,IX-1)*(FRAC_PR(IZ,IX)-FRAC_PR(IZ,IX-1))!LEFT
          Q(2,I) = -TRX(IZ,IX)*(FRAC_PR(IZ,IX+1) - FRAC_PR(IZ,IX))!RIGHT
          Q(3,I) = -TRZ(IZ-1,IX)*(FRAC_PR(IZ,IX)-FRAC_PR(IZ-1,IX))!BOTTOM
          Q(4,I) = -TRZ(IZ,IX)*(FRAC_PR(IZ+1,IX) - FRAC_PR(IZ,IX))!TOP
          Q(5,I) = ((Q(1,I)-Q(2,I))+(Q(3,I)-Q(4,I))) !NET RES
        END DO
      END DO
C
      RETURN
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
